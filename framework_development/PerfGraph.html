<!DOCTYPE html><html><head><meta charset="UTF-8"><link media="screen,projection" href="../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet"></link><link href="../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../css/moose.css" type="text/css" rel="stylesheet"></link><script src="../contrib/jquery/jquery.min.js" type="text/javascript"></script><script src="../contrib/materialize/materialize.min.js" type="text/javascript"></script><script src="../contrib/clipboard/clipboard.min.js" type="text/javascript"></script><script src="../contrib/prism/prism.min.js" type="text/javascript"></script><script src="../contrib/katex/katex.min.js" type="text/javascript"></script><script src="../contrib/fuse/fuse.min.js" type="text/javascript"></script><script src="../js/search_index.js" type="text/javascript"></script><script src="../js/init.js" type="text/javascript"></script><title>PerfGraph|Numbat</title><script src="../contrib/plotly/plotly.min.js" type="text/javascript"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://github.com/cpgr/numbat" class="right"><img src="../media/github-logo.png" class="github-mark"></img><img src="../media/github-mark.png" class="github-logo"></img></a><a href="http://cpgr.github.io/numbat/" class="left moose-logo">Numbat</a><ul class="right hide-on-med-and-down" id="nav-mobile"><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="f088682b-e093-4338-991e-ea97bae4f123">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="a24697e0-9fec-4b81-9c53-90410f757882">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="1b73b0b4-95e3-43e7-a913-c7857c8b0082">Details<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="806a3cd3-48f2-49c0-8a01-85da2da616d8">Examples<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="dc2bbf6b-718b-427f-a698-dec270fe787c">Manual<i class="material-icons right">arrow_drop_down</i></a></li></ul><ul class="dropdown-content" id="f088682b-e093-4338-991e-ea97bae4f123"><li><a href="../getting_started.html">Installation</a></li></ul><ul class="dropdown-content" id="a24697e0-9fec-4b81-9c53-90410f757882"><li><a href="../introduction.html">Introduction</a></li><li><a href="../governing_equations.html">Governing equations</a></li></ul><ul class="dropdown-content" id="1b73b0b4-95e3-43e7-a913-c7857c8b0082"><li><a href="../implementation.html">Implementation</a></li><li><a href="../input_file_syntax.html">Input file syntax</a></li><li><a href="../running_numbat.html">Running Numbat</a></li><li><a href="../systems.html">Available objects</a></li></ul><ul class="dropdown-content" id="806a3cd3-48f2-49c0-8a01-85da2da616d8"><li><a href="../example2D.html">2D</a></li><li><a href="../example3D.html">3D</a></li></ul><ul class="dropdown-content" id="dc2bbf6b-718b-427f-a698-dec270fe787c"><li><a href="../download.html">User manual</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input autocomplete="off" onkeyup="mooseSearch()" type="text" id="moose-search-box"><label for="search">http://cpgr.github.io/numbat/</label></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-action modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href="." class="breadcrumb">framework_development</a><a href="PerfGraph.html" class="breadcrumb">PerfGraph</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section data-section-text="PerfGraph" data-section-level="1" id="f2d0bfc1-aacf-4284-8358-3b5c0d8648ca"><h1>PerfGraph</h1><section class="scrollspy" data-section-text="Overview" data-section-level="2" id="e855f831-c1b2-429c-848d-4f7a1efc000c"><h2>Overview</h2><p>The <code>PerfGraph</code> object holds timing data for MOOSE. The idea behind the design is to create a nested set of timing data that faithfully represents the call structure in MOOSE.</p><p>The performance graph is part of an ecosystem of objects:</p><ul class="browser-default"><li><p><code>PerfGraph</code>: Holds the full graph and the routines for printing it out </p></li><li><p><code>PerfNode</code>: Makes up each node in the graph and holds timing information for each section of code </p></li><li><p><code>PerfGuard</code>: Scope guard used to active and deactivate timers </p></li><li><p><code>PerfGraphInterface</code>: An interface class for gaining access to the <code>PerfGraph</code> for adding timers and pulling timing data </p></li><li><p><a data-position="top" href="../source/outputs/PerfGraphOutput.html" class="tooltipped" data-tooltip="../source/outputs/PerfGraphOutput.html">PerfGraphOutput</a>: Responsible for printing out the graph </p></li><li><p><a data-position="top" href="../source/postprocessors/PerfGraphData.html" class="tooltipped" data-tooltip="../source/postprocessors/PerfGraphData.html">PerfGraphData</a>: <code>Postprocessor</code> for outputing time from the graph</p></li></ul><p>The <code>PerfGraph</code> works by registering "sections" of code using unique (<code>std::string</code>) names. The registration of a section returns a <code>PerfID</code> unique ID that is then used when referring to that section of code for starting and stopping timing. It's normal to save the <code>PerfID</code> in a member variable as a variable called <code>*_timer</code>.</p><div class="card moose-alert moose-alert-warning"><div class="card-content"><div class="moose-alert-title card-title"><span class="moose-alert-title-brand">warning</span></div><div class="moose-alert-content"><p><code>PerfGraph</code> based timing should NOT be used inside tight compute loops or anything called inside a tight compute loop (i.e. don't use it in <code>computeQpResidual()</code>). It takes about 1e-6 seconds for the timing itself to happen. That's in the MHz range... meaning that your calculation can't run any faster than that wherever this timer is! As a general rule... that means that you should have >1000 operations going on inside a timed section.</p></div></div></div></section><section class="scrollspy" data-section-text="Inheriting   From   PerfGraphInterface" data-section-level="2" id="c8f5049d-1257-4056-a476-67fdd70ecb63"><h2>Inheriting From <code>PerfGraphInterface</code></h2><p>To use for timing, make sure that your system inherits from <code>PerfGraphInterface</code>. There are a couple of different constructors for <code>PerfGraphInterface</code>:</p><p>The first one allows you to pass in a <code>MooseObject*</code> and <em>infer</em> a "prefix" based on the <code>type()</code> of the object (the name of the object). The "prefix" is prependended to any call to <code>registerTimedSection()</code> to give uniform naming from each object</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">  PerfGraphInterface(const MooseObject * moose_object);</code></pre><a data-position="top" href="#ca1325ca-839f-4a47-8f91-29ac0671e37b" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/PerfGraphInterface.h">(../moose/framework/include/interfaces/PerfGraphInterface.h)</a></div></div><p>The second one allows you to pass in a <code>MooseObject*</code> and explicitly set a <code>prefix</code>:</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);</code></pre><a data-position="top" href="#023ba339-9752-4b98-993f-7112f2b3aaa7" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/PerfGraphInterface.h">(../moose/framework/include/interfaces/PerfGraphInterface.h)</a></div></div><p>The final one is for when your object is NOT a <code>MooseObject</code> inherited object. You explicitly pass in the <code>PerfLog &amp;</code> (usually by retrieving it from the <code>MooseApp</code>) and explicitly set a <code>prefix</code>.</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);</code></pre><a data-position="top" href="#050081ab-5a7c-410e-9114-685dd717c582" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/PerfGraphInterface.h">(../moose/framework/include/interfaces/PerfGraphInterface.h)</a></div></div></section><section class="scrollspy" data-section-text="Timing   a   Section" data-section-level="2" id="347da11e-cac4-40b5-a2a6-40fea6d8cf82"><h2>Timing a Section</h2><p>Timing a section is a two part process:</p><ol start="1" class="browser-default"><li><p> Register the section and save off the <code>PerfID</code> </p></li><li><p> Using the <code>TIME_SECTION</code> macro to start timing a <code>PerfID</code></p></li></ol><section data-section-text="Registration" data-section-level="3" id="1d4f7beb-8be7-42ce-bce4-7c58d0dde632"><h3>Registration</h3><p>Registering the section of code to be timed is accomplished by calling:</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">  PerfID registerTimedSection(const std::string &amp; section_name, const unsigned int level);</code></pre><a data-position="top" href="#6445e033-2ca4-4994-9d4b-e8686c05a913" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/PerfGraphInterface.h">(../moose/framework/include/interfaces/PerfGraphInterface.h)</a></div></div><p>The <code>section_name</code> names the section of code. The <code>prefix + section_name</code> must be globally unique. <code>level</code> is the "log level" of the section. A higher number represents a more detailed log level. Here are some quick guidelines for selecting <code>level</code>:</p><ul class="browser-default"><li><p>0: Just the "root" - the whole application time </p></li><li><p>1: Minimal set of the most important routines (residual/jacobian computation, etc.) </p></li><li><p>2: Important initialization routines (setting up the mesh, initializing the systems, etc.) </p></li><li><p>3: More detailed information from levels <code>1</code> and <code>2</code> </p></li><li><p>4: This is where the Actions will start to print </p></li><li><p>5: Fairly unimportant, or less used routines </p></li><li><p>6: Routines that rarely take up much time</p></li></ul><p><code>registerTimedSection()</code> returns a <code>PerfID</code> that is a unique identifier that identifies that code section. This <code>PerfID</code> should typically get saved as a member variable of the class that is registering the section... this is normally done by initializing a <code>PerfID</code> member variable using <code>registerTimedSection()</code> in the initialization list of a constructor like so:</p><pre><code class="language-c++">
MyClass::MyClass() : _slow_function_timer(registerTimedSection(&quot;slowFunction&quot;)) {}
</code></pre></section><section data-section-text="Timing" data-section-level="3" id="46047602-3713-4ddd-8048-71182dedff18"><h3>Timing</h3><p>Once a timed section is registered and a <code>PerfID</code> is captured the section can be timed using the <code>TIME_SECTION</code> macro like so:</p><pre><code class="language-c++">

void slowFunction()
{
  TIME_SECTION(_slow_function_timer);

  // do all the things
}
</code></pre><p>What <code>TIME_SECTION</code> is doing is creating a <code>PerfGuard</code> object using the passed in <code>PerfID</code>. The <code>PerfGuard</code> tells the <code>PerfGraph</code> about the new scope and the timing is then started for that section. At the end of the function the <code>PerfGuard</code> dies and in the destructor it tells the <code>PerfGraph</code> to remove that scope. Timing this way means that it is exception safe and impossible to "foul up" because there are no "push/pop" methods to match.</p></section></section><section class="scrollspy" data-section-text="Retrieving   Time" data-section-level="2" id="25abf554-15be-472f-8654-3d06ae27a6ca"><h2>Retrieving Time</h2><p>An object that inherits from <code>PerfGraphInterface</code> can retrieve the time for a registered section by calling <code>_perf_graph.getTime()</code> (or <code>_perf_graph.getSelf</code>/<code>Children</code>/<code>TotalTime()</code>). These functions return a reference to where the time will be updated for that particular section. In the normal MOOSE way, the object should hold onto that reference and just use the value of it when it needs to know the time a section has taken. There is one small issue though... <code>_perf_graph.updateTiming()</code> should be called to ensure that the time held by the referene is up to date.</p></section><section class="scrollspy" data-section-text="The   PerfGraph   Internals" data-section-level="2" id="879df29c-0963-4116-b7c0-9030e621da23"><h2>The <code>PerfGraph</code> Internals</h2><p>The <code>PerfGraph</code> object's main purpose is to store the complete call-graph of <code>PerfNode</code>s and the current call-stack of <code>PerfNode</code>s. The graph is held by holding onto the <code>_root_node</code>. The <code>_root_node</code> (which is named <code>App</code>) is created at the time the <code>PerfGraph</code> is created (in the <code>MooseApp</code> constructor). All other scopes that are pushed into the graph are then children/descendents of the <code>_root_node</code>.</p><p>The call-stack is held within the <code>_stack</code> variable. The <code>_stack</code> is statically allocated to <code>MAX_STACK_SIZE</code> and <code>_current_position</code> is used to point at the most recent node on the stack. When a <code>PerfGuard</code> tells the <code>PerfStack</code> about a new scope the new scope is added a child to the <code>PerfNode</code> that is in the <code>_current_position</code>. <code>_current_position</code> is then incremented and the new <code>PerfNode</code> is put there.</p><p>When a scope is removed by the <code>PerfGuard</code> the <code>_current_position</code> is simply decremented - with no other action being necessrry.</p></section><section class="scrollspy" data-section-text="Printing" data-section-level="2" id="fb25a636-cbf2-4c0d-bc33-22c6bd8f774d"><h2>Printing</h2><p>Some other capability the <code>PerfGraph</code> has is the ability to print formatted tables displaying the values held in the graph. These normally shouldn't be called directly, but instead should be accessed using a <a data-position="top" href="../source/outputs/PerfGraphOutput.html" class="tooltipped" data-tooltip="../source/outputs/PerfGraphOutput.html">PerfGraphOutput</a> output object.</p><p>The <code>print()</code> method prints out an indented set of section names and shows their timing like so:</p><pre><code class="language-text">
-------------------------------------------------------------------------------------------------------------
|                 Section                |   Self(s)  |    %   | Children(s) |    %   |  Total(s)  |    %   |
-------------------------------------------------------------------------------------------------------------
| App                                    |      0.004 |   1.95 |       0.207 |  98.05 |      0.212 | 100.00 |
|   FEProblem::computeUserObjects        |      0.000 |   0.07 |       0.000 |   0.00 |      0.000 |   0.07 |
|   FEProblem::solve                     |      0.014 |   6.59 |       0.119 |  56.44 |      0.133 |  63.03 |
|     FEProblem::computeResidualInternal |      0.000 |   0.01 |       0.079 |  37.45 |      0.079 |  37.45 |
|     FEProblem::computeJacobianInternal |      0.000 |   0.01 |       0.040 |  18.83 |      0.040 |  18.84 |
|     Console::outputStep                |      0.000 |   0.12 |       0.000 |   0.00 |      0.000 |   0.12 |
|   FEProblem::outputStep                |      0.000 |   0.04 |       0.001 |   0.42 |      0.001 |   0.46 |
|     PerfGraphOutput::outputStep        |      0.000 |   0.00 |       0.000 |   0.00 |      0.000 |   0.00 |
|     Console::outputStep                |      0.001 |   0.32 |       0.000 |   0.00 |      0.001 |   0.32 |
|     CSV::outputStep                    |      0.000 |   0.10 |       0.000 |   0.00 |      0.000 |   0.10 |
-------------------------------------------------------------------------------------------------------------
</code></pre><p><code>Self</code> time is the time actually taken by the section while <code>Children</code> time is the cumulative time of all of the sub-sections below that section and <code>Total</code> is the sum of the two. The <code>%</code> columns represent the percent of the total run-time of the app for the number in the column to the left.</p><p>There are also two other ways to print information out about the graph using <code>printHeaviestBranch()</code> and <code>printHeaviestSections()</code>. These are described well over on the <a data-position="top" href="../source/outputs/PerfGraphOutput.html" class="tooltipped" data-tooltip="../source/outputs/PerfGraphOutput.html">PerfGraphOutput</a> page.</p></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a data-delay="1000" data-position="left" href="#e855f831-c1b2-429c-848d-4f7a1efc000c" class="tooltipped" data-tooltip="Overview">Overview</a></li><li><a data-delay="1000" data-position="left" href="#c8f5049d-1257-4056-a476-67fdd70ecb63" class="tooltipped" data-tooltip="Inheriting   From   PerfGraphInterface">Inheriting   From   PerfGraphInterface</a></li><li><a data-delay="1000" data-position="left" href="#347da11e-cac4-40b5-a2a6-40fea6d8cf82" class="tooltipped" data-tooltip="Timing   a   Section">Timing   a   Section</a></li><li><a data-delay="1000" data-position="left" href="#25abf554-15be-472f-8654-3d06ae27a6ca" class="tooltipped" data-tooltip="Retrieving   Time">Retrieving   Time</a></li><li><a data-delay="1000" data-position="left" href="#879df29c-0963-4116-b7c0-9030e621da23" class="tooltipped" data-tooltip="The   PerfGraph   Internals">The   PerfGraph   Internals</a></li><li><a data-delay="1000" data-position="left" href="#fb25a636-cbf2-4c0d-bc33-22c6bd8f774d" class="tooltipped" data-tooltip="Printing">Printing</a></li></ul></div></div></div></div></main></div><div id="ca1325ca-839f-4a47-8f91-29ac0671e37b" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/PerfGraphInterface.h</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifndef PERFGRAPHINTERFACE_H
#define PERFGRAPHINTERFACE_H

#include &quot;Moose.h&quot;
#include &quot;PerfGuard.h&quot;
#include &quot;InputParameters.h&quot;

#ifndef MOOSE_NO_PERF_GRAPH
#define TIME_SECTION(id) PerfGuard time_guard(_perf_graph, id);
#else
#define TIME_SECTION(id)
#endif

// Forward declarations
class PerfGraphInterface;

template &lt;&gt;
InputParameters validParams&lt;PerfGraphInterface&gt;();

/**
 * Interface for objects that needs transient capabilities
 */
class PerfGraphInterface
{
public:
  /**
   * For objects that _are_ MooseObjects with a default prefix of type()
   */
  PerfGraphInterface(const MooseObject * moose_object);

  /**
   * For objects that _are_ MooseObjects
   */
  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);

  /**
   * For objects that aren't MooseObjects
   */
  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);

  virtual ~PerfGraphInterface() = default;

protected:
  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name, const unsigned int level);

  /// Params
  const InputParameters * _pg_params;

  /// The performance graph to add to
  PerfGraph &amp; _perf_graph;

  /// A prefix to use for all sections
  std::string _prefix;
};

#endif /* PERFGRAPHINTERFACE_H */
</code></pre></div></div><div id="023ba339-9752-4b98-993f-7112f2b3aaa7" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/PerfGraphInterface.h</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifndef PERFGRAPHINTERFACE_H
#define PERFGRAPHINTERFACE_H

#include &quot;Moose.h&quot;
#include &quot;PerfGuard.h&quot;
#include &quot;InputParameters.h&quot;

#ifndef MOOSE_NO_PERF_GRAPH
#define TIME_SECTION(id) PerfGuard time_guard(_perf_graph, id);
#else
#define TIME_SECTION(id)
#endif

// Forward declarations
class PerfGraphInterface;

template &lt;&gt;
InputParameters validParams&lt;PerfGraphInterface&gt;();

/**
 * Interface for objects that needs transient capabilities
 */
class PerfGraphInterface
{
public:
  /**
   * For objects that _are_ MooseObjects with a default prefix of type()
   */
  PerfGraphInterface(const MooseObject * moose_object);

  /**
   * For objects that _are_ MooseObjects
   */
  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);

  /**
   * For objects that aren't MooseObjects
   */
  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);

  virtual ~PerfGraphInterface() = default;

protected:
  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name, const unsigned int level);

  /// Params
  const InputParameters * _pg_params;

  /// The performance graph to add to
  PerfGraph &amp; _perf_graph;

  /// A prefix to use for all sections
  std::string _prefix;
};

#endif /* PERFGRAPHINTERFACE_H */
</code></pre></div></div><div id="050081ab-5a7c-410e-9114-685dd717c582" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/PerfGraphInterface.h</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifndef PERFGRAPHINTERFACE_H
#define PERFGRAPHINTERFACE_H

#include &quot;Moose.h&quot;
#include &quot;PerfGuard.h&quot;
#include &quot;InputParameters.h&quot;

#ifndef MOOSE_NO_PERF_GRAPH
#define TIME_SECTION(id) PerfGuard time_guard(_perf_graph, id);
#else
#define TIME_SECTION(id)
#endif

// Forward declarations
class PerfGraphInterface;

template &lt;&gt;
InputParameters validParams&lt;PerfGraphInterface&gt;();

/**
 * Interface for objects that needs transient capabilities
 */
class PerfGraphInterface
{
public:
  /**
   * For objects that _are_ MooseObjects with a default prefix of type()
   */
  PerfGraphInterface(const MooseObject * moose_object);

  /**
   * For objects that _are_ MooseObjects
   */
  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);

  /**
   * For objects that aren't MooseObjects
   */
  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);

  virtual ~PerfGraphInterface() = default;

protected:
  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name, const unsigned int level);

  /// Params
  const InputParameters * _pg_params;

  /// The performance graph to add to
  PerfGraph &amp; _perf_graph;

  /// A prefix to use for all sections
  std::string _prefix;
};

#endif /* PERFGRAPHINTERFACE_H */
</code></pre></div></div><div id="6445e033-2ca4-4994-9d4b-e8686c05a913" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/PerfGraphInterface.h</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifndef PERFGRAPHINTERFACE_H
#define PERFGRAPHINTERFACE_H

#include &quot;Moose.h&quot;
#include &quot;PerfGuard.h&quot;
#include &quot;InputParameters.h&quot;

#ifndef MOOSE_NO_PERF_GRAPH
#define TIME_SECTION(id) PerfGuard time_guard(_perf_graph, id);
#else
#define TIME_SECTION(id)
#endif

// Forward declarations
class PerfGraphInterface;

template &lt;&gt;
InputParameters validParams&lt;PerfGraphInterface&gt;();

/**
 * Interface for objects that needs transient capabilities
 */
class PerfGraphInterface
{
public:
  /**
   * For objects that _are_ MooseObjects with a default prefix of type()
   */
  PerfGraphInterface(const MooseObject * moose_object);

  /**
   * For objects that _are_ MooseObjects
   */
  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);

  /**
   * For objects that aren't MooseObjects
   */
  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);

  virtual ~PerfGraphInterface() = default;

protected:
  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name, const unsigned int level);

  /// Params
  const InputParameters * _pg_params;

  /// The performance graph to add to
  PerfGraph &amp; _perf_graph;

  /// A prefix to use for all sections
  std::string _prefix;
};

#endif /* PERFGRAPHINTERFACE_H */
</code></pre></div></div></body></html>