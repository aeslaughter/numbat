<!DOCTYPE html><html><head><meta charset="UTF-8"><link media="screen,projection" href="../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet"></link><link href="../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../css/moose.css" type="text/css" rel="stylesheet"></link><script src="../contrib/jquery/jquery.min.js" type="text/javascript"></script><script src="../contrib/materialize/materialize.min.js" type="text/javascript"></script><script src="../contrib/clipboard/clipboard.min.js" type="text/javascript"></script><script src="../contrib/prism/prism.min.js" type="text/javascript"></script><script src="../contrib/katex/katex.min.js" type="text/javascript"></script><script src="../contrib/fuse/fuse.min.js" type="text/javascript"></script><script src="../js/search_index.js" type="text/javascript"></script><script src="../js/init.js" type="text/javascript"></script><title>Moose   variable   system|Numbat</title><script src="../contrib/plotly/plotly.min.js" type="text/javascript"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://github.com/cpgr/numbat" class="right"><img src="../media/github-logo.png" class="github-mark"></img><img src="../media/github-mark.png" class="github-logo"></img></a><a href="http://cpgr.github.io/numbat/" class="left moose-logo">Numbat</a><ul class="right hide-on-med-and-down" id="nav-mobile"><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="10d725ef-204b-4550-90e4-db19969bf1da">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="f63a14f6-3be1-4753-8bf6-fa5ce37f7989">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="9fc3f298-77ec-4b80-8123-265439722f65">Details<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="f151cf21-e280-41a3-9414-c2019f0877b0">Examples<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="6e8c01ab-ed8d-46e2-adc2-2996cb1d1708">Manual<i class="material-icons right">arrow_drop_down</i></a></li></ul><ul class="dropdown-content" id="10d725ef-204b-4550-90e4-db19969bf1da"><li><a href="../getting_started.html">Installation</a></li></ul><ul class="dropdown-content" id="f63a14f6-3be1-4753-8bf6-fa5ce37f7989"><li><a href="../introduction.html">Introduction</a></li><li><a href="../governing_equations.html">Governing equations</a></li></ul><ul class="dropdown-content" id="9fc3f298-77ec-4b80-8123-265439722f65"><li><a href="../implementation.html">Implementation</a></li><li><a href="../input_file_syntax.html">Input file syntax</a></li><li><a href="../running_numbat.html">Running Numbat</a></li><li><a href="../systems.html">Available objects</a></li></ul><ul class="dropdown-content" id="f151cf21-e280-41a3-9414-c2019f0877b0"><li><a href="../example2D.html">2D</a></li><li><a href="../example3D.html">3D</a></li></ul><ul class="dropdown-content" id="6e8c01ab-ed8d-46e2-adc2-2996cb1d1708"><li><a href="../download.html">User manual</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input autocomplete="off" onkeyup="mooseSearch()" type="text" id="moose-search-box"><label for="search">http://cpgr.github.io/numbat/</label></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-action modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href="." class="breadcrumb">framework_development</a><a href="moose_variables.html" class="breadcrumb">moose_variables</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section data-section-text="Moose   variable   system" data-section-level="1" id="24cc084c-3eab-4e51-acab-838167009852"><h1>Moose variable system</h1><section class="scrollspy" data-section-text="Overview" data-section-level="2" id="bd5f38fb-4fc4-401c-ae34-6449c965c8cd"><h2>Overview</h2><p>The current class hierarchy for Moose variables is shown below:</p><div style="width:50%;" class="card"><div class="card-image"><img src="../media/framework_development/moose_variable_hierarchy.svg" class="materialboxed moose-image"></img><p class="moose-caption"><span class="moose-caption-text">Moose variable hierarchy.</span></p></div></div><p><code>MooseVariableBase</code> is the primitive base class from which all variables inherit. It includes methods for accessing the variable finite element type and order, degress of freedom, scaling factor, name, and associated <code>SystemBase</code>. Two classes inherit directly from <code>MooseVariableBase</code>: <code>MooseVariableFEBase</code> and <code>MooseVariableScalar</code>. <code>MooseVariableScalar</code> represents a Moose variable that is constant over the spatial domain. It has a number of degrees of freedom equal to the order of the variable, e.g. the following variable block would declare a <code>MooseVariableScalar</code> with two associated degrees of freedom:</p><pre><code class="language-text">
[AuxVariables]
  [./aux_scalar]
    order = SECOND
    family = SCALAR
  [../]
[]
</code></pre><p><code>MooseVariableFEBase</code> is an abstract class that encompasses all finite-element type variables; all variables that vary spatially ultimately inherit from <code>MooseVariableFEBase</code>. The class implements all the relevant variable methods other than those that return the actual variable solution or variable shape functions, since the return type in the latter case depends on whether the finite-element variable is scalar-valued (single-component) or vector-valued (multi-component) in nature. The existence of the <code>MooseVariableFEBase</code> class allows construction of containers that hold both single- and multi-component finite element variables. This is useful for instance in the <code>Assembly</code> class where we can abstract the coupling matrix entries or in Jacobian computing objects like <code>Kernels</code> when we want to fetch the numerical ID of the variable using <code>coupled</code>. Moreoever, this design structure mirrors that of the <code>FE</code> design in LibMesh, where <code>FEAbstract</code> is an abstract base class that implements all methods independent of <code>FE</code> type and the class template <code>FEGenericBase&lt;T&gt;</code> implements the type dependent methods analogous to <code>MooseVariableFE&lt;T&gt;</code>.</p><p><code>MooseVariableFE&lt;T&gt;</code> implements methods that return the variable's solution and its associated shape functions. Additionally, it contains the methods responsible for computing the variable solution at quadrature points given the degree of freedom values computed from the previous non-linear solution. "Standard" or "traditional" finite element variables that are single-component are instantiated with the template argument <code>Real</code>; these hold variables of finite element families <code>LAGRANGE</code>, <code>MONOMIAL</code>, <code>HERMITE</code>, etc. Multi-component vector finite element variables are instantiated with the template argument <code>RealVectorValue</code> and currently encompass the finite element familes <code>NEDELEC_ONE</code> and <code>LAGRANGE_VEC</code>. The former is useful for electromagnetic applications or for general PDEs that involve a curl operation. The latter is potentially useful for tensor mechanic or Navier-Stokes simulations where historically displacement or velocity variables have been broken up component-wise. To hide the templating of the Moose variable system from other framework code, <code>MooseVariableFE&lt;Real&gt;</code> and <code>MooseVariableFE&lt;RealVectorValue&gt;</code> have been aliased to <code>MooseVariable</code> and <code>VectorMooseVariable</code> respectively.</p><p>Finally, <code>MooseVariableConstMonomial</code> is a class that takes advantage of its finite element type (constant value on an element) to optimize its solution computing routines. Consequently, it overrides the <code>computeElemValues</code> and similar methods of <code>MooseVariableFE&lt;Real&gt;</code>.</p></section><section class="scrollspy" data-section-text="Accessors" data-section-level="2" id="e0a35e5e-542c-4e13-a073-d77155861c17"><h2>Accessors</h2><p>There are a myriad of ways to acess Moose variables from user interfaces. We'll outline a few below.</p><section data-section-text="SystemBase" data-section-level="3" id="2f8981df-a98a-4075-9f2d-aa288e3df3ea"><h3>SystemBase</h3><p>It's common for interface objects (<code>Kernel</code> objects for example) to have a <code>_sys</code> member. The <code>_sys</code> member has the following variable accessor methods which take a <code>THREAD_ID</code> and either a <code>std::string</code> variable name or <code>unsigned</code> variable ID as arguments:</p><ul class="browser-default"><li><p><code>getVariable</code>: returns a reference to a <code>MooseVariableFEBase</code>. Useful when access to the variable finite element solution or shape functions is not needed </p></li><li><p><code>getFieldVariable</code>: this is a templated method that takes as its template argument either <code>Real</code> or <code>RealVectorValue</code> and returns a reference to a <code>MooseVariable</code> or a <code>VectorMooseVariable</code> respectively. Useful when the user knows and needs the complete type </p></li><li><p><code>getScalarVariable</code>: returns a reference to a <code>MooseVariableScalar</code></p></li></ul><p>These getter methods ultimately query different map containers in the <code>VariableWarehouse</code>.</p></section><section data-section-text="SubProblem" data-section-level="3" id="78693e03-bc36-4b45-8a79-694c539231e8"><h3>SubProblem</h3><p>Another common interface object member is <code>_subproblem</code>. <code>_subproblem</code> has the following acessors methods which take <code>THREAD_ID</code> and a <code>std::string</code> variable name as arguments (note that acessors through variable IDs do not exist through <code>SubProblem</code>):</p><ul class="browser-default"><li><p><code>getVariable</code>: returns a reference to a <code>MooseVariableFEBase</code>. Useful when access to the variable finite element solution or shape functions is not needed. Calls <code>SystemBase::getVariable</code> </p></li><li><p><code>getStandardVariable</code>: returns a reference to a <code>MooseVariable</code>. Useful when the user knows and needs the complete type. Calls <code>SystemBase::getFieldVariable&lt;Real&gt;</code> </p></li><li><p><code>getVectorVariable</code>: returns a reference to a <code>VectorMooseVariable</code>. Useful when the user knows and needs the complete type. Calls <code>SystemBase::getFieldVariable&lt;RealVectorValue&gt;</code> </p></li><li><p><code>getScalarVariable</code>: returns a reference to a <code>MooseVariableScalar</code></p></li></ul><p>Note that the template abstraction available in <code>SystemBase</code> is not available in <code>SubProblem</code>. This is because the accessor methods in <code>SubProblem</code> are pure virtual, i.e. their implementations are made in derived classes which eliminates the choice of a templated accessor method in the base <code>SubProblem</code> class.</p></section><section data-section-text="Coupleable" data-section-level="3" id="23ced259-3eaf-4b19-a874-25bbf7b1cbe1"><h3>Coupleable</h3><p>Since most interface objects already supply the user with the primary variable, the most common way a user should be accessing Moose variables is through <code>Coupleable</code> methods. The following accessor methods return actual Moose variable objects and take as arguments the variable name and the "component" which is used when the user passes in multiple variables to a single <code>CoupledVar</code> parameter:</p><ul class="browser-default"><li><p><code>getFEVar</code>: returns a pointer to a <code>MooseVariableFEBase</code>. Useful when access to the variable finite element solution or shape functions is not needed </p></li><li><p><code>getVar</code>: returns a pointer to a <code>MooseVariable</code>. Useful when the complete type is needed </p></li><li><p><code>getVectorVar</code>: returns a pointer to a <code>VectorMooseVariable</code>. Useful when the complete type is needed</p></li></ul><p>When the user/developer wants access to multiple/all coupled variables, they can call the following methods which take no arguments:</p><ul class="browser-default"><li><p><code>getCoupledMooseVars</code>: returns <strong>all</strong> coupled Moose variables, i.e. both single-component <code>MooseVariables</code> and multi-component <code>VectorMooseVariables</code>. Consequently the return type is <code>std::vector&lt;MooseVariableFEBase *&gt;</code> </p></li><li><p><code>getCoupledStandardMooseVars</code>: returns all coupled single-component <code>MooseVariables</code> as a <code>std::vector&lt;MooseVariable *&gt;</code> </p></li><li><p><code>getCoupledVectorMooseVars</code>: returns all coupled multi-component <code>VectorMooseVariables</code> as a <code>std::vector&lt;VectorMooseVariable *&gt;</code></p></li></ul><p>Often times there is no need for the user/developer to access the actual Moose variable object. Instead they require the variable finite element solution or gradient. Some of these methods are exemplified below:</p><ul class="browser-default"><li><p><code>coupledValue</code>: takes a variable name (should correspond to a <strong>single-component</strong> <code>MooseVariable</code>) and returns the finite element solution at the quadrature points (<code>VariableValue</code>) </p></li><li><p><code>coupledVectorValue</code>: takes a variable name (should correspond to a <strong>multi-component</strong> <code>VectorMooseVariable</code>) and returns the finite element solution at the quadrature points (<code>VectorVariableValue</code>) </p></li><li><p><code>coupledGradient</code>: takes a variable name (should correspond to a <strong>single-component</strong> <code>MooseVariable</code>) and returns the finite element solution gradient at the quadrature points (<code>VariableGradient</code>) </p></li><li><p><code>coupledCurl</code>: takes a variable name (should correspond to a <strong>multi-component</strong> <code>VectorMooseVariable</code>) and returns the curl of the finite element solution at the quadrature points (<code>VectorVariableCurl</code>)</p></li></ul></section></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a data-delay="1000" data-position="left" href="#bd5f38fb-4fc4-401c-ae34-6449c965c8cd" class="tooltipped" data-tooltip="Overview">Overview</a></li><li><a data-delay="1000" data-position="left" href="#e0a35e5e-542c-4e13-a073-d77155861c17" class="tooltipped" data-tooltip="Accessors">Accessors</a></li></ul></div></div></div></div></main></div></body></html>