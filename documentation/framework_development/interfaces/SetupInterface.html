<!DOCTYPE html><html><head><meta charset="UTF-8"><link media="screen,projection" href="../../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet"></link><link href="../../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../../css/moose.css" type="text/css" rel="stylesheet"></link><script src="../../../contrib/jquery/jquery.min.js" type="text/javascript"></script><script src="../../../contrib/materialize/materialize.min.js" type="text/javascript"></script><script src="../../../contrib/clipboard/clipboard.min.js" type="text/javascript"></script><script src="../../../contrib/prism/prism.min.js" type="text/javascript"></script><script src="../../../contrib/katex/katex.min.js" type="text/javascript"></script><script src="../../../contrib/fuse/fuse.min.js" type="text/javascript"></script><script src="../../../js/search_index.js" type="text/javascript"></script><script src="../../../js/init.js" type="text/javascript"></script><title>SetupInterface   ( execute _ on )|Numbat</title></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://github.com/cpgr/numbat" class="right"><img src="../../../media/github-logo.png" class="github-mark"></img><img src="../../../media/github-mark.png" class="github-logo"></img></a><a href="http://cpgr.github.io/numbat/" class="left moose-logo">Numbat</a><ul class="right hide-on-med-and-down" id="nav-mobile"><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="0f6dbacb-088c-4434-b0fc-550df18024a5">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="9fc30b81-a51f-49d3-a0a8-e4390aec57a5">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="d5da9acf-2143-492b-bdd2-1b76e5e833e4">Details<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="25595319-4d72-4ba4-b483-d3e8ce045c1c">Examples<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="dcb9d3d2-0a68-4735-9753-677a3dc44927">Manual<i class="material-icons right">arrow_drop_down</i></a></li></ul><ul class="dropdown-content" id="0f6dbacb-088c-4434-b0fc-550df18024a5"><li><a href="../../../getting_started.html">Installation</a></li></ul><ul class="dropdown-content" id="9fc30b81-a51f-49d3-a0a8-e4390aec57a5"><li><a href="../../../introduction.html">Introduction</a></li><li><a href="../../../governing_equations.html">Governing equations</a></li></ul><ul class="dropdown-content" id="d5da9acf-2143-492b-bdd2-1b76e5e833e4"><li><a href="../../../implementation.html">Implementation</a></li><li><a href="../../../input_file_syntax.html">Input file syntax</a></li><li><a href="../../../running_numbat.html">Running Numbat</a></li><li><a href="../../../systems.html">Available objects</a></li></ul><ul class="dropdown-content" id="25595319-4d72-4ba4-b483-d3e8ce045c1c"><li><a href="../../../example2D.html">2D</a></li><li><a href="../../../example3D.html">3D</a></li></ul><ul class="dropdown-content" id="dcb9d3d2-0a68-4735-9753-677a3dc44927"><li><a href="../../../download.html">User manual</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input autocomplete="off" onkeyup="mooseSearch()" type="text" id="moose-search-box"><label for="search">http://cpgr.github.io/numbat/</label></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-action modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><span class="breadcrumb">documentation</span><a href=".." class="breadcrumb">framework_development</a><a href="." class="breadcrumb">interfaces</a><a href="SetupInterface.html" class="breadcrumb">SetupInterface</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section data-section-text="SetupInterface   ( execute _ on )" data-section-level="1" id="ce96167b-4a60-4d10-95ea-83b80cfb37a1"><h1>SetupInterface (execute_on)</h1><p>Most user-facing objects in MOOSE inherit from the SetupInterface class. This class provides two features to objects. Foremost, it provides the the "execute_on" parameter, which, as the name suggests, dictates when the object is to be executed. Secondly, it adds virtual setup methods that allow derived classes to perform setup applications prior to execution.</p><section class="section scrollspy" data-section-text="Execute   On" data-section-level="2" id="a092fc44-2c82-43bd-8558-165889e34d42"><h2>Execute On</h2><p>Any object inheriting from the SetupInterface, that adds the <code>validParams&lt;SetupInterface&gt;</code> within its own parameters, will have an "execute_on" parameter that can be set to various flags, the most common flags are listed below.</p><div class="moose-table-div"><table><thead><tr><th>Execute Flag</th><th>Description</th></tr></thead><tbody><tr><td>INITIAL</td><td>Prior to the first time step.</td></tr></tbody><tbody><tr><td>TIMESTEP_BEGIN</td><td>Prior to the solve for each time step.</td></tr></tbody><tbody><tr><td>NONLINEAR</td><td>Prior do each non-linear iteration during the solve.</td></tr></tbody><tbody><tr><td>LINEAR</td><td>Prior do each linear iteration during the solve.</td></tr></tbody><tbody><tr><td>TIMESTEP_END</td><td>After the solve for each time step.</td></tr></tbody><tbody><tr><td>SUBDOMAIN</td><td>Executes when the subdomain (i.e., "blocks") change during calculations.</td></tr></tbody></table></div><p>The "execute_on" parameter can be set to a single flag or multiple flags. For example, it may be desirable to only execute an object initially because the state of the auxiliary computation does not vary. In the input file snippet below, the <a data-position="top" href="../../systems/AuxKernels/ElementLengthAux.html" class="tooltipped" data-tooltip="../../systems/AuxKernels/ElementLengthAux.html">ElementLengthAux</a> computation only needs to be computed initially, thus the "exeucte_on" parameter is set as such.</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-text">
[AuxKernels]
  [./min]
    type = ElementLengthAux
    variable = min
    method = min
    execute_on = initial
  [../]
  [./max]
    type = ElementLengthAux
    variable = max
    method = max
    execute_on = initial
  [../]
[../]</code></pre><a data-position="top" href="#2d1e599d-c63b-40d8-b4ff-6feb320f4295" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/test/tests/auxkernels/element_length/element_length.i">(../moose/test/tests/auxkernels/element_length/element_length.i)</a></div></div><p>Alternatively, it is often desirable to run a computation with multiple execute flags. For example, in the input file snippet below a <a data-position="top" href="../../systems/Controls/TimePeriod.html" class="tooltipped" data-tooltip="../../systems/Controls/TimePeriod.html">TimePeriod</a> control object that is responsible for enabling in <a data-position="top" href="../../systems/Dampers/index.html" class="tooltipped" data-tooltip="../../systems/Dampers/index.html">Damper</a> object needs to be run initially and prior to each timestep to guarantee that the damper is enabled when desired.</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-text">
[Controls]
  [./damping_control]
    type = TimePeriod
    disable_objects = '*::const_damp'
    start_time = 0.25
    execute_on = 'initial timestep_begin'
  [../]
[]</code></pre><a data-position="top" href="#63895d5e-30d3-43be-8abd-1547a6c7c964" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/test/tests/controls/time_periods/dampers/control.i">(../moose/test/tests/controls/time_periods/dampers/control.i)</a></div></div><p>Depending on the system these options or others will be available, since as discussed in <a href="#creating-custom-execute-flags" data-tooltip="#creating-custom-execute-flags" data-position="top" class="tooltipped">Creating Custom Execute Flags</a> custom flags may be added. The complete list of execution flags is provided by MOOSE are listed in the "registerExecFlags" function.</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;MooseApp.h&quot;
#include &quot;MooseRevision.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;MooseInit.h&quot;
#include &quot;Executioner.h&quot;
#include &quot;PetscSupport.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;CommandLine.h&quot;
#include &quot;InfixIterator.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;MeshModifier.h&quot;
#include &quot;DependencyResolver.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseObjectAction.h&quot;
#include &quot;InputParameterWarehouse.h&quot;
#include &quot;SystemInfo.h&quot;
#include &quot;RestartableDataIO.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;FileOutput.h&quot;
#include &quot;ConsoleUtils.h&quot;
#include &quot;JsonSyntaxTree.h&quot;
#include &quot;JsonInputFileFormatter.h&quot;
#include &quot;SONDefinitionFormatter.h&quot;
#include &quot;RelationshipManager.h&quot;
#include &quot;Registry.h&quot;
#include &quot;SerializerGuard.h&quot;

// Regular expression includes
#include &quot;pcrecpp.h&quot;

#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/mesh_refinement.h&quot;
#include &quot;libmesh/string_to_enum.h&quot;
#include &quot;libmesh/checkpoint_io.h&quot;

// System include for dynamic library methods
#include &lt;dlfcn.h&gt;
#include &lt;sys/utsname.h&gt; // utsname

// C++ includes
#include &lt;numeric&gt; // std::accumulate
#include &lt;fstream&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt; // for system()
#include &lt;chrono&gt;
#include &lt;thread&gt;

#define QUOTE(macro) stringifyName(macro)

template &lt;&gt;
InputParameters
validParams&lt;MooseApp&gt;()
{
  InputParameters params = emptyInputParameters();

  params.addCommandLineParam&lt;bool&gt;(
      &quot;display_version&quot;, &quot;-v --version&quot;, false, &quot;Print application version&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;input_file&quot;, &quot;-i &lt;input_file&gt;&quot;, &quot;Specify an input file&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;mesh_only&quot;,
      &quot;--mesh-only [mesh_file_name]&quot;,
      &quot;Setup and Output the input mesh only (Default: \&quot;&lt;input_file_name&gt;_in.e\&quot;)&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;show_input&quot;,
                                   &quot;--show-input&quot;,
                                   false,
                                   &quot;Shows the parsed input file before running the simulation.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_outputs&quot;, &quot;--show-outputs&quot;, false, &quot;Shows the output execution time information.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_controls&quot;, &quot;--show-controls&quot;, false, &quot;Shows the Control logic available and executed.&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;no_color&quot;, &quot;--no-color&quot;, false, &quot;Disable coloring of all Console outputs.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;color&quot;,
                                          &quot;--color [auto,on,off]&quot;,
                                          &quot;default-on&quot;,
                                          &quot;Whether to use color in console output (default 'on').&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;help&quot;, &quot;-h --help&quot;, false, &quot;Displays CLI usage statement.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;minimal&quot;,
      &quot;--minimal&quot;,
      false,
      &quot;Ignore input file and build a minimal application with Transient executioner.&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;definition&quot;, &quot;--definition&quot;, &quot;Shows a SON style input definition dump for input validation&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;dump&quot;, &quot;--dump [search_string]&quot;, &quot;Shows a dump of available input file syntax.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry&quot;, &quot;--registry&quot;, &quot;Lists all known objects and actions.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry_hit&quot;, &quot;--registry-hit&quot;, &quot;Lists all known objects and actions in hit format.&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;apptype&quot;, &quot;--type&quot;, false, &quot;Return the name of the application object.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;yaml&quot;, &quot;--yaml&quot;, &quot;Dumps input file syntax in YAML format.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;json&quot;, &quot;--json&quot;, &quot;Dumps input file syntax in JSON format.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;syntax&quot;, &quot;--syntax&quot;, false, &quot;Dumps the associated Action syntax paths ONLY&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;check_input&quot;,
                                   &quot;--check-input&quot;,
                                   false,
                                   &quot;Check the input file (i.e. requires -i &lt;filename&gt;) and quit.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;list_constructed_objects&quot;,
      &quot;--list-constructed-objects&quot;,
      false,
      &quot;List all moose object type names constructed by the master app factory.&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;n_threads&quot;, &quot;--n-threads=&lt;n&gt;&quot;, 1, &quot;Runs the specified number of threads per process&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;warn_unused&quot;, &quot;-w --warn-unused&quot;, false, &quot;Warn about unused input file options&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;error_unused&quot;,
                                   &quot;-e --error-unused&quot;,
                                   false,
                                   &quot;Error when encountering unused input file options&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_override&quot;,
      &quot;-o --error-override&quot;,
      false,
      &quot;Error when encountering overridden or parameters supplied multiple times&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_deprecated&quot;, &quot;--error-deprecated&quot;, false, &quot;Turn deprecated code messages into Errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;distributed_mesh&quot;,
      &quot;--distributed-mesh&quot;,
      false,
      &quot;The libMesh Mesh underlying MooseMesh should always be a DistributedMesh&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;split_mesh&quot;,
      &quot;--split-mesh [splits]&quot;,
      &quot;comma-separated list of numbers of chunks to split the mesh into&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;split_file&quot;,
                                          &quot;--split-file [filename]&quot;,
                                          &quot;&quot;,
                                          &quot;optional name of split mesh file(s) to write/read&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;use_split&quot;, &quot;--use-split&quot;, false, &quot;use split distributed mesh files&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;refinements&quot;,
      &quot;-r &lt;n&gt;&quot;,
      0,
      &quot;Specify additional initial uniform refinements for automatic scaling&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recover&quot;,
                                          &quot;--recover [file_base]&quot;,
                                          &quot;Continue the calculation.  If file_base is omitted then &quot;
                                          &quot;the most recent recovery file will be utilized&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recoversuffix&quot;,
                                          &quot;--recoversuffix [suffix]&quot;,
                                          &quot;Use a different file extension, other than cpr, &quot;
                                          &quot;for a recovery file&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;half_transient&quot;,
                                   &quot;--half-transient&quot;,
                                   false,
                                   &quot;When true the simulation will only run half of &quot;
                                   &quot;its specified transient (ie half the &quot;
                                   &quot;timesteps).  This is useful for testing &quot;
                                   &quot;recovery and restart&quot;);

  // No default on these two options, they must not both be valid
  params.addCommandLineParam&lt;bool&gt;(
      &quot;trap_fpe&quot;,
      &quot;--trap-fpe&quot;,
      &quot;Enable Floating Point Exception handling in critical sections of &quot;
      &quot;code.  This is enabled automatically in DEBUG mode&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_trap_fpe&quot;,
                                   &quot;--no-trap-fpe&quot;,
                                   &quot;Disable Floating Point Exception handling in critical &quot;
                                   &quot;sections of code when using DEBUG mode.&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;error&quot;, &quot;--error&quot;, false, &quot;Turn all warnings into errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;timing&quot;,
      &quot;-t --timing&quot;,
      false,
      &quot;Enable all performance logging for timing purposes. This will disable all &quot;
      &quot;screen output of performance logs for all Console objects.&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_timing&quot;,
                                   &quot;--no-timing&quot;,
                                   false,
                                   &quot;Disabled performance logging. Overrides -t or --timing &quot;
                                   &quot;if passed in conjunction with this flag&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;allow_test_objects&quot;, &quot;--allow-test-objects&quot;, false, &quot;Register test objects and syntax.&quot;);

  // Options ignored by MOOSE but picked up by libMesh, these are here so that they are displayed in
  // the application help
  params.addCommandLineParam&lt;bool&gt;(
      &quot;keep_cout&quot;,
      &quot;--keep-cout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;redirect_stdout&quot;,
      &quot;--redirect-stdout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);

  // Options for debugging
  params.addCommandLineParam&lt;std::string&gt;(&quot;start_in_debugger&quot;,
                                          &quot;--start-in-debugger &lt;debugger&gt;&quot;,
                                          &quot;Start the application and attach a debugger.  This will &quot;
                                          &quot;launch xterm windows using the command you specify for &quot;
                                          &quot;'debugger'&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;,
                                           &quot;--stop-for-debugger [seconds]&quot;,
                                           30,
                                           &quot;Pauses the application during startup for the &quot;
                                           &quot;specified time to allow for connection of debuggers.&quot;);

  params.addPrivateParam&lt;std::string&gt;(&quot;_app_name&quot;); // the name passed to AppFactory::create
  params.addPrivateParam&lt;std::string&gt;(&quot;_type&quot;);
  params.addPrivateParam&lt;int&gt;(&quot;_argc&quot;);
  params.addPrivateParam&lt;char **&gt;(&quot;_argv&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_level&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_number&quot;);

  return params;
}

MooseApp::MooseApp(InputParameters parameters)
  : ConsoleStreamInterface(*this),
    ParallelObject(*parameters.get&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(
        &quot;_comm&quot;)), // Can't call getParam() before pars is set
    _name(parameters.get&lt;std::string&gt;(&quot;_app_name&quot;)),
    _pars(parameters),
    _type(getParam&lt;std::string&gt;(&quot;_type&quot;)),
    _comm(getParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;)),
    _output_position_set(false),
    _start_time_set(false),
    _start_time(0.0),
    _global_time_offset(0.0),
    _output_warehouse(*this),
    _input_parameter_warehouse(new InputParameterWarehouse()),
    _action_factory(*this),
    _action_warehouse(*this, _syntax, _action_factory),
    _parser(*this, _action_warehouse),
    _use_nonlinear(true),
    _use_eigen_value(false),
    _enable_unused_check(WARN_UNUSED),
    _factory(*this),
    _error_overridden(false),
    _ready_to_exit(false),
    _initial_from_file(false),
    _distributed_mesh_on_command_line(false),
    _recover(false),
    _restart(false),
#ifdef DEBUG
    _trap_fpe(true),
#else
    _trap_fpe(false),
#endif
    _recover_suffix(&quot;cpr&quot;),
    _half_transient(false),
    _check_input(getParam&lt;bool&gt;(&quot;check_input&quot;)),
    _restartable_data(libMesh::n_threads()),
    _multiapp_level(
        isParamValid(&quot;_multiapp_level&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_level&quot;) : 0),
    _multiapp_number(
        isParamValid(&quot;_multiapp_number&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_number&quot;) : 0)
{
  Registry::addKnownLabel(_type);

  if (isParamValid(&quot;_argc&quot;) &amp;&amp; isParamValid(&quot;_argv&quot;))
  {
    int argc = getParam&lt;int&gt;(&quot;_argc&quot;);
    char ** argv = getParam&lt;char **&gt;(&quot;_argv&quot;);

    _sys_info = libmesh_make_unique&lt;SystemInfo&gt;(argc, argv);
  }
  if (isParamValid(&quot;_command_line&quot;))
    _command_line = getParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  else
    mooseError(&quot;Valid CommandLine object required&quot;);

  if (_check_input &amp;&amp; isParamValid(&quot;recover&quot;))
    mooseError(&quot;Cannot run --check-input with --recover. Recover files might not exist&quot;);

  if (isParamValid(&quot;start_in_debugger&quot;))
  {
    auto command = getParam&lt;std::string&gt;(&quot;start_in_debugger&quot;);

    Moose::out &lt;&lt; &quot;Starting in debugger using: &quot; &lt;&lt; command &lt;&lt; std::endl;

    auto hostname = MooseUtils::hostname();

    std::stringstream command_stream;

    // This will start XTerm and print out some info first... then run the debugger
    command_stream &lt;&lt; &quot;xterm -e \&quot;echo 'Rank: &quot; &lt;&lt; processor_id() &lt;&lt; &quot;  Hostname: &quot; &lt;&lt; hostname
                   &lt;&lt; &quot;  PID: &quot; &lt;&lt; getpid() &lt;&lt; &quot;'; echo ''; &quot;;

    // Figure out how to run the debugger
    if (command.find(&quot;lldb&quot;) != std::string::npos || command.find(&quot;gdb&quot;) != std::string::npos)
      command_stream &lt;&lt; command &lt;&lt; &quot; -p &quot; &lt;&lt; getpid();
    else
      mooseError(&quot;Unknown debugger: &quot;,
                 command,
                 &quot;\nIf this is truly what you meant then contact moose-users to have a discussion &quot;
                 &quot;about adding your debugger.&quot;);

    // Finish up the command
    command_stream &lt;&lt; &quot;\&quot;&quot;
                   &lt;&lt; &quot; &amp; &quot;;

    std::string command_string = command_stream.str();
    Moose::out &lt;&lt; &quot;Running: &quot; &lt;&lt; command_string &lt;&lt; std::endl;

    std::system(command_string.c_str());

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(10));
  }

  if (!parameters.isParamSetByAddParam(&quot;stop_for_debugger&quot;))
  {
    Moose::out &lt;&lt; &quot;\nStopping for &quot; &lt;&lt; getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)
               &lt;&lt; &quot; seconds to allow attachment from a debugger.\n&quot;;

    Moose::out &lt;&lt; &quot;\nAll of the processes you can connect to:\n&quot;;
    Moose::out &lt;&lt; &quot;rank - hostname - pid\n&quot;;

    auto hostname = MooseUtils::hostname();

    {
      // The 'false' turns off the serialization warning
      SerializerGuard sg(_communicator, false); // Guarantees that the processors print in order
      Moose::err &lt;&lt; processor_id() &lt;&lt; &quot; - &quot; &lt;&lt; hostname &lt;&lt; &quot; - &quot; &lt;&lt; getpid() &lt;&lt; &quot;\n&quot;;
    }

    Moose::out &lt;&lt; &quot;\nWaiting...\n&quot; &lt;&lt; std::endl;

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)));
  }
}</code></pre><a data-position="top" href="#6cbbd69c-91b4-46a5-ae69-c463af8dacbf" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/src/base/MooseApp.C">(../moose/framework/src/base/MooseApp.C)</a></div></div></section><section class="section scrollspy" data-section-text="Modifying   Execute   On" data-section-level="2" id="66208399-4310-4fdf-a129-7a8fcf6487bb"><h2>Modifying Execute On</h2><p>When creating objects that inherit from SetupInterface it is possible to set, add, or remove available execute flags by retrieving and then modifying the <code>ExecFlagEnum</code> parameter. For example, consider the snippet below (see <a data-position="top" href="#ff2a6c40-21c6-4d26-adc3-e20c78a8d072" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/src/outputs/Output.C"></a>).</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());</code></pre><a data-position="top" href="#b522af5d-859a-42ad-abb0-7deb9c7aaac0" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/src/outputs/Output.C">(../moose/framework/src/outputs/Output.C)</a></div></div><p>First, the "execute_on" is retrieved for modification by using the "set" method. Notice, that a second boolean argument is passed to "set", this second flag enables "quite mode". Quite mode will modify the parameter silently as if the default was the modified parameter. In this case, the parameter will be listed as un-modified by the user. That is, <code>InputParameters::isParamSetByUser</code> returns false, if quite mode is not enabled this method would return true.</p><p>Second, the two new execution flags are added (<code>EXEC_FINAL</code> and <code>EXEC_FAILED</code>), therefore these additional options are available to all classes (all Output objects in this case) that inherit from this object.</p><p>Third, the default active flags are set to <code>EXEC_INITIAL</code> and <code>EXEC_TIMESTEP_END</code>, which are the defaults for all Output objects.</p><p>Finally, the documentation string for the "execute_on" parameter for the Output objects is update to reflect the changes made to the parameter. The <code>ExecFlagEnum</code> has a convenience function that generates a documentation string that includes the available options in the string.</p></section><section class="section scrollspy" data-section-text="Virtual   Setup   Methods" data-section-level="2" id="6714d0c6-0ff7-4bd2-9fee-5ffe84418104"><h2>Virtual Setup Methods</h2><p>The SetupInterface includes virtual methods that correspond to the primary execute flags with MOOSE, these methods are listed in the header as shown here.</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">/**
* Gets called at the beginning of the simulation before this object is asked to do its job
*/
virtual void initialSetup();
/**
* Gets called at the beginning of the timestep before this object is asked to do its job
*/
virtual void timestepSetup();
/**
* Gets called just before the Jacobian is computed and before this object is asked to do its job
*/
virtual void jacobianSetup();
/**
* Gets called just before the residual is computed and before this object is asked to do its job
*/
virtual void residualSetup();
/**
* Gets called when the subdomain changes (i.e. in a Jacobian or residual loop) and before this
* object is asked to do its job
*/
virtual void subdomainSetup();</code></pre><a data-position="top" href="#2a6c59b3-1dd4-46a5-80fd-3ff51c8adb02" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/SetupInterface.h">(../moose/framework/include/interfaces/SetupInterface.h)</a></div></div><p>In general, these methods should be utilized to perform "setup" procedures prior to the calls to execute for the corresponding execute flag.</p><div class="card moose-alert moose-alert-note"><div class="card-content"><div class="moose-alert-title card-title"><span class="moose-alert-title-brand">note</span></div><div class="moose-alert-content"><p>A few of the methods were created prior to the execute flags, thus the names do not correspond but they remain as is to keep the API consistent: the "jacobianSetup" methods is called prior to the "NONLINEAR" execute flag and the "residualSetup" is called prior to the "LINEAR" execute flag.</p></div></div></div></section><section class="section scrollspy" data-section-text="Creating   Custom   Execute   Flags" data-section-level="2" id="3e1e6da8-6951-4b1c-9e02-8e567a274975"><h2>Creating Custom Execute Flags</h2><p>It is possible to create custom execute flags for an application. To create at utilize a custom execute flag the following steps should be followed.</p><section data-section-text="1 .   Declare   and   Define   an   Execute   Flag" data-section-level="3" id="4297a87c-e8ea-473f-8c7d-b3fa77d4da69"><h3>1. Declare and Define an Execute Flag</h3><p>Within your application a new global <code>const</code> should be declared in a header file. For example, within the <code>LevelSetApp</code> within MOOSE modules, there is a header (LevelSetTypes.h) that declares a new flag (<code>EXEC_ADAPT_MESH</code>).</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifndef LEVELSETTYPES_H
#define LEVELSETTYPES_H

#include &quot;Moose.h&quot;

namespace LevelSet
{
extern const ExecFlagType EXEC_ADAPT_MESH;
extern const ExecFlagType EXEC_COMPUTE_MARKERS;
}

#endif</code></pre><a data-position="top" href="#d075849a-a44d-416e-accc-b92d29d29160" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/include/base/LevelSetTypes.h">(../moose/modules/level_set/include/base/LevelSetTypes.h)</a></div></div><p>This new global must be defined, which occurs in the corresponding source file. When defining the new flags with a name and optionally an integer value.</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Level set includes
#include &quot;LevelSetTypes.h&quot;

// MOOSE includes
#include &quot;MooseEnumItem.h&quot;

const ExecFlagType LevelSet::EXEC_ADAPT_MESH(&quot;ADAPT_MESH&quot;);
const ExecFlagType LevelSet::EXEC_COMPUTE_MARKERS(&quot;COMPUTE_MARKERS&quot;, 1234);</code></pre><a data-position="top" href="#a5368b76-e3eb-4773-b49d-7d993362e356" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/src/base/LevelSetTypes.C">(../moose/modules/level_set/src/base/LevelSetTypes.C)</a></div></div></section><section data-section-text="2 .   Register   the   Execute   Flag" data-section-level="3" id="0990cb09-0408-4ad6-b702-5c5e56f55e5b"><h3>2. Register the Execute Flag</h3><p>After the new flag(s) are declared and defined, it must be registered with MOOSE. This is accomplished in similar fashion as object registration, simply add the newly created flag by calling <code>registerExecFlag</code> with the <code>registerExecFlags</code> function of your application.</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">LevelSetApp::registerExecFlags(Factory &amp; factory)
{
  registerExecFlag(LevelSet::EXEC_ADAPT_MESH);
  registerExecFlag(LevelSet::EXEC_COMPUTE_MARKERS);
}</code></pre><a data-position="top" href="#cabc99e3-1219-4b7e-a6fb-bacee6f8710f" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/src/base/LevelSetApp.C">(../moose/modules/level_set/src/base/LevelSetApp.C)</a></div></div><div class="card moose-alert moose-alert-note"><div class="card-content"><div class="moose-alert-title card-title"><span class="moose-alert-title-brand">note</span></div><div class="moose-alert-content"><p>If your application does not have a <code>registerExecFlags</code> function, it must be created. This can be done automatically by running the <code>add_exec_flag_registration.py</code> that is located in the scripts directory within MOOSE.</p></div></div></div></section><section data-section-text="3 .   Add   the   Execute   Flag   to   InputParameters" data-section-level="3" id="60f798d1-5885-4c54-8c1c-d38bf0072ada"><h3>3. Add the Execute Flag to InputParameters</h3><p>After a flag is registered, it must be made available to the object(s) in which are desired to be executed with the custom flag. This is done by adding this new flag to an existing objects valid parameters. For example, the following adds the <code>EXEC_ADAPT_MESH</code> flag to a <code>Transfer</code> object.</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">ExecFlagEnum &amp; exec = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);
exec.addAvailableFlags(LevelSet::EXEC_ADAPT_MESH, LevelSet::EXEC_COMPUTE_MARKERS);
exec = {LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH};</code></pre><a data-position="top" href="#3b27f70f-e2a1-46bf-9a35-7e925371622d" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/src/transfers/LevelSetMeshRefinementTransfer.C">(../moose/modules/level_set/src/transfers/LevelSetMeshRefinementTransfer.C)</a></div></div></section><section data-section-text="4 .   Use   the   Execute   Flag" data-section-level="3" id="7e824442-5dd1-4551-8cfb-f2390661fed1"><h3>4. Use the Execute Flag</h3><p>Depending on what type of custom computation is desired, various MOOSE execution calls accept execution flags, which will spawn calculations. For example, the <code>LevelSetProblem</code> contains a custom method that uses the <code>EXEC_ADAPT_MESH</code> flag to preform an additional <a data-position="top" href="../../systems/Transfers/index.html" class="tooltipped" data-tooltip="../../systems/Transfers/index.html"><code>MultiAppTransfer</code></a> execution.</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">execMultiAppTransfers(LevelSet::EXEC_ADAPT_MESH, MultiAppTransfer::TO_MULTIAPP);</code></pre><a data-position="top" href="#a5a07017-99c4-4929-bd4f-e99b9ea4ad53" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/src/base/LevelSetProblem.C">(../moose/modules/level_set/src/base/LevelSetProblem.C)</a></div></div></section></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a data-delay="1000" data-position="left" href="#a092fc44-2c82-43bd-8558-165889e34d42" class="tooltipped" data-tooltip="Execute   On">Execute   On</a></li><li><a data-delay="1000" data-position="left" href="#66208399-4310-4fdf-a129-7a8fcf6487bb" class="tooltipped" data-tooltip="Modifying   Execute   On">Modifying   Execute   On</a></li><li><a data-delay="1000" data-position="left" href="#6714d0c6-0ff7-4bd2-9fee-5ffe84418104" class="tooltipped" data-tooltip="Virtual   Setup   Methods">Virtual   Setup   Methods</a></li><li><a data-delay="1000" data-position="left" href="#3e1e6da8-6951-4b1c-9e02-8e567a274975" class="tooltipped" data-tooltip="Creating   Custom   Execute   Flags">Creating   Custom   Execute   Flags</a></li></ul></div></div></div></div></main></div><div id="2d1e599d-c63b-40d8-b4ff-6feb320f4295" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/test/tests/auxkernels/element_length/element_length.i</h4><pre><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 100
[]

[AuxVariables]
  [./min]
  [../]
  [./max]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./min]
    type = ElementLengthAux
    variable = min
    method = min
    execute_on = initial
  [../]
  [./max]
    type = ElementLengthAux
    variable = max
    method = max
    execute_on = initial
  [../]
[../]

[Problem]
  type = FEProblem
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = 'TIMESTEP_END'
  exodus = true
[]
</code></pre></div></div><div id="63895d5e-30d3-43be-8abd-1547a6c7c964" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/test/tests/controls/time_periods/dampers/control.i</h4><pre><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = CoefDiffusion
    variable = u
    coef = 0.1
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = PJFNK
  petsc_options_iname = '-pc_type -pc_hypre_type'
  petsc_options_value = 'hypre boomeramg'
  nl_rel_tol = 0.95e-8
[]

[Postprocessors]
  [./nlin]
    type = NumNonlinearIterations
  [../]
[]

[Dampers]
  [./const_damp]
    type = ConstantDamper
    damping = 0.9
  [../]
[]

[Outputs]
  csv = true
[]

[Controls]
  [./damping_control]
    type = TimePeriod
    disable_objects = '*::const_damp'
    start_time = 0.25
    execute_on = 'initial timestep_begin'
  [../]
[]
</code></pre></div></div><div id="6cbbd69c-91b4-46a5-ae69-c463af8dacbf" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/src/base/MooseApp.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;MooseApp.h&quot;
#include &quot;MooseRevision.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;MooseInit.h&quot;
#include &quot;Executioner.h&quot;
#include &quot;PetscSupport.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;CommandLine.h&quot;
#include &quot;InfixIterator.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;MeshModifier.h&quot;
#include &quot;DependencyResolver.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseObjectAction.h&quot;
#include &quot;InputParameterWarehouse.h&quot;
#include &quot;SystemInfo.h&quot;
#include &quot;RestartableDataIO.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;FileOutput.h&quot;
#include &quot;ConsoleUtils.h&quot;
#include &quot;JsonSyntaxTree.h&quot;
#include &quot;JsonInputFileFormatter.h&quot;
#include &quot;SONDefinitionFormatter.h&quot;
#include &quot;RelationshipManager.h&quot;
#include &quot;Registry.h&quot;
#include &quot;SerializerGuard.h&quot;

// Regular expression includes
#include &quot;pcrecpp.h&quot;

#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/mesh_refinement.h&quot;
#include &quot;libmesh/string_to_enum.h&quot;
#include &quot;libmesh/checkpoint_io.h&quot;

// System include for dynamic library methods
#include &lt;dlfcn.h&gt;
#include &lt;sys/utsname.h&gt; // utsname

// C++ includes
#include &lt;numeric&gt; // std::accumulate
#include &lt;fstream&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt; // for system()
#include &lt;chrono&gt;
#include &lt;thread&gt;

#define QUOTE(macro) stringifyName(macro)

template &lt;&gt;
InputParameters
validParams&lt;MooseApp&gt;()
{
  InputParameters params = emptyInputParameters();

  params.addCommandLineParam&lt;bool&gt;(
      &quot;display_version&quot;, &quot;-v --version&quot;, false, &quot;Print application version&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;input_file&quot;, &quot;-i &lt;input_file&gt;&quot;, &quot;Specify an input file&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;mesh_only&quot;,
      &quot;--mesh-only [mesh_file_name]&quot;,
      &quot;Setup and Output the input mesh only (Default: \&quot;&lt;input_file_name&gt;_in.e\&quot;)&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;show_input&quot;,
                                   &quot;--show-input&quot;,
                                   false,
                                   &quot;Shows the parsed input file before running the simulation.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_outputs&quot;, &quot;--show-outputs&quot;, false, &quot;Shows the output execution time information.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_controls&quot;, &quot;--show-controls&quot;, false, &quot;Shows the Control logic available and executed.&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;no_color&quot;, &quot;--no-color&quot;, false, &quot;Disable coloring of all Console outputs.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;color&quot;,
                                          &quot;--color [auto,on,off]&quot;,
                                          &quot;default-on&quot;,
                                          &quot;Whether to use color in console output (default 'on').&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;help&quot;, &quot;-h --help&quot;, false, &quot;Displays CLI usage statement.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;minimal&quot;,
      &quot;--minimal&quot;,
      false,
      &quot;Ignore input file and build a minimal application with Transient executioner.&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;definition&quot;, &quot;--definition&quot;, &quot;Shows a SON style input definition dump for input validation&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;dump&quot;, &quot;--dump [search_string]&quot;, &quot;Shows a dump of available input file syntax.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry&quot;, &quot;--registry&quot;, &quot;Lists all known objects and actions.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry_hit&quot;, &quot;--registry-hit&quot;, &quot;Lists all known objects and actions in hit format.&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;apptype&quot;, &quot;--type&quot;, false, &quot;Return the name of the application object.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;yaml&quot;, &quot;--yaml&quot;, &quot;Dumps input file syntax in YAML format.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;json&quot;, &quot;--json&quot;, &quot;Dumps input file syntax in JSON format.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;syntax&quot;, &quot;--syntax&quot;, false, &quot;Dumps the associated Action syntax paths ONLY&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;check_input&quot;,
                                   &quot;--check-input&quot;,
                                   false,
                                   &quot;Check the input file (i.e. requires -i &lt;filename&gt;) and quit.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;list_constructed_objects&quot;,
      &quot;--list-constructed-objects&quot;,
      false,
      &quot;List all moose object type names constructed by the master app factory.&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;n_threads&quot;, &quot;--n-threads=&lt;n&gt;&quot;, 1, &quot;Runs the specified number of threads per process&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;warn_unused&quot;, &quot;-w --warn-unused&quot;, false, &quot;Warn about unused input file options&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;error_unused&quot;,
                                   &quot;-e --error-unused&quot;,
                                   false,
                                   &quot;Error when encountering unused input file options&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_override&quot;,
      &quot;-o --error-override&quot;,
      false,
      &quot;Error when encountering overridden or parameters supplied multiple times&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_deprecated&quot;, &quot;--error-deprecated&quot;, false, &quot;Turn deprecated code messages into Errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;distributed_mesh&quot;,
      &quot;--distributed-mesh&quot;,
      false,
      &quot;The libMesh Mesh underlying MooseMesh should always be a DistributedMesh&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;split_mesh&quot;,
      &quot;--split-mesh [splits]&quot;,
      &quot;comma-separated list of numbers of chunks to split the mesh into&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;split_file&quot;,
                                          &quot;--split-file [filename]&quot;,
                                          &quot;&quot;,
                                          &quot;optional name of split mesh file(s) to write/read&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;use_split&quot;, &quot;--use-split&quot;, false, &quot;use split distributed mesh files&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;refinements&quot;,
      &quot;-r &lt;n&gt;&quot;,
      0,
      &quot;Specify additional initial uniform refinements for automatic scaling&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recover&quot;,
                                          &quot;--recover [file_base]&quot;,
                                          &quot;Continue the calculation.  If file_base is omitted then &quot;
                                          &quot;the most recent recovery file will be utilized&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recoversuffix&quot;,
                                          &quot;--recoversuffix [suffix]&quot;,
                                          &quot;Use a different file extension, other than cpr, &quot;
                                          &quot;for a recovery file&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;half_transient&quot;,
                                   &quot;--half-transient&quot;,
                                   false,
                                   &quot;When true the simulation will only run half of &quot;
                                   &quot;its specified transient (ie half the &quot;
                                   &quot;timesteps).  This is useful for testing &quot;
                                   &quot;recovery and restart&quot;);

  // No default on these two options, they must not both be valid
  params.addCommandLineParam&lt;bool&gt;(
      &quot;trap_fpe&quot;,
      &quot;--trap-fpe&quot;,
      &quot;Enable Floating Point Exception handling in critical sections of &quot;
      &quot;code.  This is enabled automatically in DEBUG mode&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_trap_fpe&quot;,
                                   &quot;--no-trap-fpe&quot;,
                                   &quot;Disable Floating Point Exception handling in critical &quot;
                                   &quot;sections of code when using DEBUG mode.&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;error&quot;, &quot;--error&quot;, false, &quot;Turn all warnings into errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;timing&quot;,
      &quot;-t --timing&quot;,
      false,
      &quot;Enable all performance logging for timing purposes. This will disable all &quot;
      &quot;screen output of performance logs for all Console objects.&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_timing&quot;,
                                   &quot;--no-timing&quot;,
                                   false,
                                   &quot;Disabled performance logging. Overrides -t or --timing &quot;
                                   &quot;if passed in conjunction with this flag&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;allow_test_objects&quot;, &quot;--allow-test-objects&quot;, false, &quot;Register test objects and syntax.&quot;);

  // Options ignored by MOOSE but picked up by libMesh, these are here so that they are displayed in
  // the application help
  params.addCommandLineParam&lt;bool&gt;(
      &quot;keep_cout&quot;,
      &quot;--keep-cout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;redirect_stdout&quot;,
      &quot;--redirect-stdout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);

  // Options for debugging
  params.addCommandLineParam&lt;std::string&gt;(&quot;start_in_debugger&quot;,
                                          &quot;--start-in-debugger &lt;debugger&gt;&quot;,
                                          &quot;Start the application and attach a debugger.  This will &quot;
                                          &quot;launch xterm windows using the command you specify for &quot;
                                          &quot;'debugger'&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;,
                                           &quot;--stop-for-debugger [seconds]&quot;,
                                           30,
                                           &quot;Pauses the application during startup for the &quot;
                                           &quot;specified time to allow for connection of debuggers.&quot;);

  params.addPrivateParam&lt;std::string&gt;(&quot;_app_name&quot;); // the name passed to AppFactory::create
  params.addPrivateParam&lt;std::string&gt;(&quot;_type&quot;);
  params.addPrivateParam&lt;int&gt;(&quot;_argc&quot;);
  params.addPrivateParam&lt;char **&gt;(&quot;_argv&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_level&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_number&quot;);

  return params;
}

MooseApp::MooseApp(InputParameters parameters)
  : ConsoleStreamInterface(*this),
    ParallelObject(*parameters.get&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(
        &quot;_comm&quot;)), // Can't call getParam() before pars is set
    _name(parameters.get&lt;std::string&gt;(&quot;_app_name&quot;)),
    _pars(parameters),
    _type(getParam&lt;std::string&gt;(&quot;_type&quot;)),
    _comm(getParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;)),
    _output_position_set(false),
    _start_time_set(false),
    _start_time(0.0),
    _global_time_offset(0.0),
    _output_warehouse(*this),
    _input_parameter_warehouse(new InputParameterWarehouse()),
    _action_factory(*this),
    _action_warehouse(*this, _syntax, _action_factory),
    _parser(*this, _action_warehouse),
    _use_nonlinear(true),
    _use_eigen_value(false),
    _enable_unused_check(WARN_UNUSED),
    _factory(*this),
    _error_overridden(false),
    _ready_to_exit(false),
    _initial_from_file(false),
    _distributed_mesh_on_command_line(false),
    _recover(false),
    _restart(false),
#ifdef DEBUG
    _trap_fpe(true),
#else
    _trap_fpe(false),
#endif
    _recover_suffix(&quot;cpr&quot;),
    _half_transient(false),
    _check_input(getParam&lt;bool&gt;(&quot;check_input&quot;)),
    _restartable_data(libMesh::n_threads()),
    _multiapp_level(
        isParamValid(&quot;_multiapp_level&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_level&quot;) : 0),
    _multiapp_number(
        isParamValid(&quot;_multiapp_number&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_number&quot;) : 0)
{
  Registry::addKnownLabel(_type);

  if (isParamValid(&quot;_argc&quot;) &amp;&amp; isParamValid(&quot;_argv&quot;))
  {
    int argc = getParam&lt;int&gt;(&quot;_argc&quot;);
    char ** argv = getParam&lt;char **&gt;(&quot;_argv&quot;);

    _sys_info = libmesh_make_unique&lt;SystemInfo&gt;(argc, argv);
  }
  if (isParamValid(&quot;_command_line&quot;))
    _command_line = getParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  else
    mooseError(&quot;Valid CommandLine object required&quot;);

  if (_check_input &amp;&amp; isParamValid(&quot;recover&quot;))
    mooseError(&quot;Cannot run --check-input with --recover. Recover files might not exist&quot;);

  if (isParamValid(&quot;start_in_debugger&quot;))
  {
    auto command = getParam&lt;std::string&gt;(&quot;start_in_debugger&quot;);

    Moose::out &lt;&lt; &quot;Starting in debugger using: &quot; &lt;&lt; command &lt;&lt; std::endl;

    auto hostname = MooseUtils::hostname();

    std::stringstream command_stream;

    // This will start XTerm and print out some info first... then run the debugger
    command_stream &lt;&lt; &quot;xterm -e \&quot;echo 'Rank: &quot; &lt;&lt; processor_id() &lt;&lt; &quot;  Hostname: &quot; &lt;&lt; hostname
                   &lt;&lt; &quot;  PID: &quot; &lt;&lt; getpid() &lt;&lt; &quot;'; echo ''; &quot;;

    // Figure out how to run the debugger
    if (command.find(&quot;lldb&quot;) != std::string::npos || command.find(&quot;gdb&quot;) != std::string::npos)
      command_stream &lt;&lt; command &lt;&lt; &quot; -p &quot; &lt;&lt; getpid();
    else
      mooseError(&quot;Unknown debugger: &quot;,
                 command,
                 &quot;\nIf this is truly what you meant then contact moose-users to have a discussion &quot;
                 &quot;about adding your debugger.&quot;);

    // Finish up the command
    command_stream &lt;&lt; &quot;\&quot;&quot;
                   &lt;&lt; &quot; &amp; &quot;;

    std::string command_string = command_stream.str();
    Moose::out &lt;&lt; &quot;Running: &quot; &lt;&lt; command_string &lt;&lt; std::endl;

    std::system(command_string.c_str());

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(10));
  }

  if (!parameters.isParamSetByAddParam(&quot;stop_for_debugger&quot;))
  {
    Moose::out &lt;&lt; &quot;\nStopping for &quot; &lt;&lt; getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)
               &lt;&lt; &quot; seconds to allow attachment from a debugger.\n&quot;;

    Moose::out &lt;&lt; &quot;\nAll of the processes you can connect to:\n&quot;;
    Moose::out &lt;&lt; &quot;rank - hostname - pid\n&quot;;

    auto hostname = MooseUtils::hostname();

    {
      // The 'false' turns off the serialization warning
      SerializerGuard sg(_communicator, false); // Guarantees that the processors print in order
      Moose::err &lt;&lt; processor_id() &lt;&lt; &quot; - &quot; &lt;&lt; hostname &lt;&lt; &quot; - &quot; &lt;&lt; getpid() &lt;&lt; &quot;\n&quot;;
    }

    Moose::out &lt;&lt; &quot;\nWaiting...\n&quot; &lt;&lt; std::endl;

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)));
  }
}

void
MooseApp::checkRegistryLabels()
{
  Registry::checkLabels();
}

MooseApp::~MooseApp()
{
  _action_warehouse.clear();
  _executioner.reset();

  delete _input_parameter_warehouse;

#ifdef LIBMESH_HAVE_DLOPEN
  // Close any open dynamic libraries
  for (const auto &amp; it : _lib_handles)
    dlclose(it.second);
#endif
}

std::string
MooseApp::getFrameworkVersion() const
{
  return MOOSE_VERSION;
}

std::string
MooseApp::getVersion() const
{
  return MOOSE_VERSION;
}

std::string
MooseApp::getPrintableVersion() const
{
  return getPrintableName() + &quot; Version: &quot; + getVersion();
}

void
MooseApp::setupOptions()
{
  // MOOSE was updated to have the ability to register execution flags in similar fashion as
  // objects. However, this change requires all *App.C/h files to be updated with the new
  // registerExecFlags method. To avoid breaking all applications the default MOOSE flags
  // are added if nothing has been added to this point. In the future this could go away or
  // perhaps be a warning.
  if (_execute_flags.items().empty())
    Moose::registerExecFlags(_factory);

  // Print the header, this is as early as possible
  std::string hdr(header() + &quot;\n&quot;);
  if (multiAppLevel() &gt; 0)
    MooseUtils::indentMessage(_name, hdr);
  Moose::out &lt;&lt; hdr &lt;&lt; std::flush;

  if (getParam&lt;bool&gt;(&quot;error_unused&quot;))
    setCheckUnusedFlag(true);
  else if (getParam&lt;bool&gt;(&quot;warn_unused&quot;))
    setCheckUnusedFlag(false);

  if (getParam&lt;bool&gt;(&quot;error_override&quot;))
    setErrorOverridden();

  _distributed_mesh_on_command_line = getParam&lt;bool&gt;(&quot;distributed_mesh&quot;);

  _half_transient = getParam&lt;bool&gt;(&quot;half_transient&quot;);

  // The no_timing flag takes precedence over the timing flag.
  if (getParam&lt;bool&gt;(&quot;no_timing&quot;))
    _pars.set&lt;bool&gt;(&quot;timing&quot;) = false;

  if (isParamValid(&quot;trap_fpe&quot;) &amp;&amp; isParamValid(&quot;no_trap_fpe&quot;))
    mooseError(&quot;Cannot use both \&quot;--trap-fpe\&quot; and \&quot;--no-trap-fpe\&quot; flags.&quot;);
  if (isParamValid(&quot;trap_fpe&quot;))
    _trap_fpe = true;
  else if (isParamValid(&quot;no_trap_fpe&quot;))
    _trap_fpe = false;

  // Turn all warnings in MOOSE to errors (almost see next logic block)
  Moose::_warnings_are_errors = getParam&lt;bool&gt;(&quot;error&quot;);

  // Deprecated messages can be toggled to errors independently from everything else.
  Moose::_deprecated_is_error = getParam&lt;bool&gt;(&quot;error_deprecated&quot;);

  if (isUltimateMaster()) // makes sure coloring isn't reset incorrectly in multi-app settings
  {
    // Toggle the color console off
    Moose::setColorConsole(true, true); // set default color condition
    if (getParam&lt;bool&gt;(&quot;no_color&quot;))
      Moose::setColorConsole(false);

    char * c_color = std::getenv(&quot;MOOSE_COLOR&quot;);
    std::string color = &quot;on&quot;;
    if (c_color)
      color = c_color;
    if (getParam&lt;std::string&gt;(&quot;color&quot;) != &quot;default-on&quot;)
      color = getParam&lt;std::string&gt;(&quot;color&quot;);

    if (color == &quot;auto&quot;)
      Moose::setColorConsole(true);
    else if (color == &quot;on&quot;)
      Moose::setColorConsole(true, true);
    else if (color == &quot;off&quot;)
      Moose::setColorConsole(false);
    else
      mooseWarning(&quot;ignoring invalid --color arg (want 'auto', 'on', or 'off')&quot;);
  }

  // this warning goes below --color processing to honor that setting for
  // the warning. And below settings for warnings/error setup.
  if (getParam&lt;bool&gt;(&quot;no_color&quot;))
    mooseDeprecated(&quot;The --no-color flag is deprecated. Use '--color off' instead.&quot;);

// If there's no threading model active, but the user asked for
// --n-threads &gt; 1 on the command line, throw a mooseError.  This is
// intended to prevent situations where the user has potentially
// built MOOSE incorrectly (neither TBB nor pthreads found) and is
// asking for multiple threads, not knowing that there will never be
// any threads launched.
#if !LIBMESH_USING_THREADS
  if (libMesh::command_line_value(&quot;--n-threads&quot;, 1) &gt; 1)
    mooseError(&quot;You specified --n-threads &gt; 1, but there is no threading model active!&quot;);
#endif

  // Build a minimal running application, ignoring the input file.
  if (getParam&lt;bool&gt;(&quot;minimal&quot;))
    createMinimalApp();

  else if (getParam&lt;bool&gt;(&quot;display_version&quot;))
  {
    Moose::perf_log.disable_logging();
    Moose::out &lt;&lt; getPrintableVersion() &lt;&lt; std::endl;
    _ready_to_exit = true;
    return;
  }
  else if (getParam&lt;bool&gt;(&quot;help&quot;))
  {
    Moose::perf_log.disable_logging();

    _command_line-&gt;printUsage();
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;dump&quot;))
  {
    Moose::perf_log.disable_logging();

    // Get command line argument following --dump on command line
    std::string following_arg = getParam&lt;std::string&gt;(&quot;dump&quot;);

    // The argument following --dump is a parameter search string,
    // which can be empty.
    std::string param_search;
    if (!following_arg.empty() &amp;&amp; (following_arg.find('-') != 0))
      param_search = following_arg;

    JsonSyntaxTree tree(param_search);
    _parser.buildJsonSyntaxTree(tree);
    JsonInputFileFormatter formatter;
    Moose::out &lt;&lt; &quot;### START DUMP DATA ###\n&quot;
               &lt;&lt; formatter.toString(tree.getRoot()) &lt;&lt; &quot;\n### END DUMP DATA ###\n&quot;;
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;registry&quot;))
  {
    Moose::out &lt;&lt; &quot;Label\tType\tName\tClass\tFile\n&quot;;

    auto &amp; objmap = Registry::allObjects();
    for (auto &amp; entry : objmap)
    {
      for (auto &amp; obj : entry.second)
      {
        std::string name = obj._name;
        if (name.empty())
          name = obj._alias;
        if (name.empty())
          name = obj._classname;

        Moose::out &lt;&lt; entry.first &lt;&lt; &quot;\tobject\t&quot; &lt;&lt; name &lt;&lt; &quot;\t&quot; &lt;&lt; obj._classname &lt;&lt; &quot;\t&quot;
                   &lt;&lt; obj._file &lt;&lt; &quot;\n&quot;;
      }
    }

    auto &amp; actmap = Registry::allActions();
    for (auto &amp; entry : actmap)
    {
      for (auto &amp; act : entry.second)
        Moose::out &lt;&lt; entry.first &lt;&lt; &quot;\taction\t&quot; &lt;&lt; act._name &lt;&lt; &quot;\t&quot; &lt;&lt; act._classname &lt;&lt; &quot;\t&quot;
                   &lt;&lt; act._file &lt;&lt; &quot;\n&quot;;
    }

    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;registry_hit&quot;))
  {
    Moose::out &lt;&lt; &quot;### START REGISTRY DATA ###\n&quot;;

    hit::Section root(&quot;&quot;);
    auto sec = new hit::Section(&quot;registry&quot;);
    root.addChild(sec);
    auto objsec = new hit::Section(&quot;objects&quot;);
    sec-&gt;addChild(objsec);

    auto &amp; objmap = Registry::allObjects();
    for (auto &amp; entry : objmap)
    {
      for (auto &amp; obj : entry.second)
      {
        std::string name = obj._name;
        if (name.empty())
          name = obj._alias;
        if (name.empty())
          name = obj._classname;

        auto ent = new hit::Section(&quot;entry&quot;);
        objsec-&gt;addChild(ent);
        ent-&gt;addChild(new hit::Field(&quot;label&quot;, hit::Field::Kind::String, entry.first));
        ent-&gt;addChild(new hit::Field(&quot;type&quot;, hit::Field::Kind::String, &quot;object&quot;));
        ent-&gt;addChild(new hit::Field(&quot;name&quot;, hit::Field::Kind::String, name));
        ent-&gt;addChild(new hit::Field(&quot;class&quot;, hit::Field::Kind::String, obj._classname));
        ent-&gt;addChild(new hit::Field(&quot;file&quot;, hit::Field::Kind::String, obj._file));
      }
    }

    auto actsec = new hit::Section(&quot;actions&quot;);
    sec-&gt;addChild(actsec);
    auto &amp; actmap = Registry::allActions();
    for (auto &amp; entry : actmap)
    {
      for (auto &amp; act : entry.second)
      {
        auto ent = new hit::Section(&quot;entry&quot;);
        actsec-&gt;addChild(ent);
        ent-&gt;addChild(new hit::Field(&quot;label&quot;, hit::Field::Kind::String, entry.first));
        ent-&gt;addChild(new hit::Field(&quot;type&quot;, hit::Field::Kind::String, &quot;action&quot;));
        ent-&gt;addChild(new hit::Field(&quot;task&quot;, hit::Field::Kind::String, act._name));
        ent-&gt;addChild(new hit::Field(&quot;class&quot;, hit::Field::Kind::String, act._classname));
        ent-&gt;addChild(new hit::Field(&quot;file&quot;, hit::Field::Kind::String, act._file));
      }
    }

    Moose::out &lt;&lt; root.render();

    Moose::out &lt;&lt; &quot;\n### END REGISTRY DATA ###\n&quot;;
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;definition&quot;))
  {
    Moose::perf_log.disable_logging();
    JsonSyntaxTree tree(&quot;&quot;);
    _parser.buildJsonSyntaxTree(tree);
    SONDefinitionFormatter formatter;
    Moose::out &lt;&lt; formatter.toString(tree.getRoot()) &lt;&lt; &quot;\n&quot;;
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;yaml&quot;))
  {
    Moose::perf_log.disable_logging();

    _parser.initSyntaxFormatter(Parser::YAML, true);

    // Get command line argument following --yaml on command line
    std::string yaml_following_arg = getParam&lt;std::string&gt;(&quot;yaml&quot;);

    // If the argument following --yaml is non-existent or begins with
    // a dash, call buildFullTree() with an empty string, otherwise
    // pass the argument following --yaml.
    if (yaml_following_arg.empty() || (yaml_following_arg.find('-') == 0))
      _parser.buildFullTree(&quot;&quot;);
    else
      _parser.buildFullTree(yaml_following_arg);

    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;json&quot;))
  {
    Moose::perf_log.disable_logging();

    // Get command line argument following --json on command line
    std::string json_following_arg = getParam&lt;std::string&gt;(&quot;json&quot;);

    // The argument following --json is a parameter search string,
    // which can be empty.
    std::string search;
    if (!json_following_arg.empty() &amp;&amp; (json_following_arg.find('-') != 0))
      search = json_following_arg;

    JsonSyntaxTree tree(search);
    _parser.buildJsonSyntaxTree(tree);

    Moose::out &lt;&lt; &quot;**START JSON DATA**\n&quot; &lt;&lt; tree.getRoot() &lt;&lt; &quot;\n**END JSON DATA**\n&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;syntax&quot;))
  {
    Moose::perf_log.disable_logging();

    std::multimap&lt;std::string, Syntax::ActionInfo&gt; syntax = _syntax.getAssociatedActions();
    Moose::out &lt;&lt; &quot;**START SYNTAX DATA**\n&quot;;
    for (const auto &amp; it : syntax)
      Moose::out &lt;&lt; it.first &lt;&lt; &quot;\n&quot;;
    Moose::out &lt;&lt; &quot;**END SYNTAX DATA**\n&quot; &lt;&lt; std::endl;
    _ready_to_exit = true;
  }
  else if (_input_filename != &quot;&quot; ||
           isParamValid(&quot;input_file&quot;)) // They already specified an input filename
  {
    if (_input_filename == &quot;&quot;)
      _input_filename = getParam&lt;std::string&gt;(&quot;input_file&quot;);

    if (isParamValid(&quot;recover&quot;))
    {
      // We need to set the flag manually here since the recover parameter is a string type (takes
      // an optional filename)
      _recover = true;

      // Get command line argument following --recover on command line
      std::string recover_following_arg = getParam&lt;std::string&gt;(&quot;recover&quot;);

      // If the argument following --recover is non-existent or begins with
      // a dash then we are going to eventually find the newest recovery file to use
      if (!(recover_following_arg.empty() || (recover_following_arg.find('-') == 0)))
        _recover_base = recover_following_arg;
    }

    // Optionally get command line argument following --recoversuffix
    // on command line.  Currently this argument applies to both
    // recovery and restart files.
    if (isParamValid(&quot;recoversuffix&quot;))
    {
      _recover_suffix = getParam&lt;std::string&gt;(&quot;recoversuffix&quot;);
    }

    _parser.parse(_input_filename);

    if (isParamValid(&quot;mesh_only&quot;))
    {
      _syntax.registerTaskName(&quot;mesh_only&quot;, true);
      _syntax.addDependency(&quot;mesh_only&quot;, &quot;setup_mesh_complete&quot;);
      _action_warehouse.setFinalTask(&quot;mesh_only&quot;);
    }
    else if (isParamValid(&quot;split_mesh&quot;))
    {
      _syntax.registerTaskName(&quot;split_mesh&quot;, true);
      _syntax.addDependency(&quot;split_mesh&quot;, &quot;setup_mesh_complete&quot;);
      _action_warehouse.setFinalTask(&quot;split_mesh&quot;);
    }
    _action_warehouse.build();
  }
  else if (getParam&lt;bool&gt;(&quot;apptype&quot;))
  {
    Moose::perf_log.disable_logging();
    Moose::out &lt;&lt; type() &lt;&lt; std::endl;
    _ready_to_exit = true;
  }
  else
  {
    Moose::perf_log.disable_logging();

    if (_check_input)
      mooseError(&quot;You specified --check-input, but did not provide an input file. Add -i &quot;
                 &quot;&lt;inputfile&gt; to your command line.&quot;);

    _command_line-&gt;printUsage();
    _ready_to_exit = true;
  }
}

void
MooseApp::setInputFileName(std::string input_filename)
{
  _input_filename = input_filename;
}

std::string
MooseApp::getOutputFileBase() const
{
  return _output_file_base;
}

void
MooseApp::runInputFile()
{
  // If ready to exit has been set, then just return
  if (_ready_to_exit)
    return;

  _action_warehouse.executeAllActions();

  if (isParamValid(&quot;mesh_only&quot;) || isParamValid(&quot;split_mesh&quot;))
    _ready_to_exit = true;
  else if (getParam&lt;bool&gt;(&quot;list_constructed_objects&quot;))
  {
    // TODO: ask multiapps for their constructed objects
    _ready_to_exit = true;
    std::vector&lt;std::string&gt; obj_list = _factory.getConstructedObjects();
    Moose::out &lt;&lt; &quot;**START OBJECT DATA**\n&quot;;
    for (const auto &amp; name : obj_list)
      Moose::out &lt;&lt; name &lt;&lt; &quot;\n&quot;;
    Moose::out &lt;&lt; &quot;**END OBJECT DATA**\n&quot; &lt;&lt; std::endl;
  }
}

void
MooseApp::errorCheck()
{
  bool warn = _enable_unused_check == WARN_UNUSED;
  bool err = _enable_unused_check == ERROR_UNUSED;

  _parser.errorCheck(*_comm, warn, err);

  auto apps = _executioner-&gt;feProblem().getMultiAppWarehouse().getObjects();
  for (auto app : apps)
    for (unsigned int i = 0; i &lt; app-&gt;numLocalApps(); i++)
      app-&gt;localApp(i)-&gt;errorCheck();
}

void
MooseApp::executeExecutioner()
{
  // If ready to exit has been set, then just return
  if (_ready_to_exit)
    return;

  // run the simulation
  if (_executioner)
  {
#ifdef LIBMESH_HAVE_PETSC
    Moose::PetscSupport::petscSetupOutput(_command_line.get());
#endif

    _executioner-&gt;init();
    errorCheck();
    _executioner-&gt;execute();
  }
  else
    mooseError(&quot;No executioner was specified (go fix your input file)&quot;);
}

bool
MooseApp::isRecovering() const
{
  return _recover;
}

bool
MooseApp::isRestarting() const
{
  return _restart;
}

bool
MooseApp::hasRecoverFileBase()
{
  return !_recover_base.empty();
}

void
MooseApp::registerRecoverableData(std::string name)
{
  _recoverable_data.insert(name);
}

std::shared_ptr&lt;Backup&gt;
MooseApp::backup()
{
  FEProblemBase &amp; fe_problem = _executioner-&gt;feProblem();

  RestartableDataIO rdio(fe_problem);

  return rdio.createBackup();
}

void
MooseApp::restore(std::shared_ptr&lt;Backup&gt; backup, bool for_restart)
{
  // This means that a Backup is coming through to use for restart / recovery
  // We should just cache it for now
  if (!_executioner)
  {
    _cached_backup = backup;
    return;
  }

  FEProblemBase &amp; fe_problem = _executioner-&gt;feProblem();

  RestartableDataIO rdio(fe_problem);

  rdio.restoreBackup(backup, for_restart);
}

void
MooseApp::setCheckUnusedFlag(bool warn_is_error)
{
  /**
   * _enable_unused_check is initialized to WARN_UNUSED. If an application chooses to promote
   * this value to ERROR_UNUSED programmatically prior to running the simulation, we certainly
   * don't want to allow it to fall back. Therefore, we won't set it if it's already at the
   * highest value (i.e. error). If however a developer turns it off, it can still be turned on.
   */
  if (_enable_unused_check != ERROR_UNUSED || warn_is_error)
    _enable_unused_check = warn_is_error ? ERROR_UNUSED : WARN_UNUSED;
  else
    mooseInfo(&quot;Ignoring request to turn off or warn about unused parameters.\n&quot;);
}

void
MooseApp::disableCheckUnusedFlag()
{
  _enable_unused_check = OFF;
}

void
MooseApp::setErrorOverridden()
{
  _error_overridden = true;
}

void
MooseApp::run()
{
  Moose::perf_log.push(&quot;Full Runtime&quot;, &quot;Application&quot;);

  Moose::perf_log.push(&quot;Application Setup&quot;, &quot;Setup&quot;);
  try
  {
    setupOptions();
    runInputFile();
  }
  catch (std::exception &amp; err)
  {
    mooseError(err.what());
  }
  Moose::perf_log.pop(&quot;Application Setup&quot;, &quot;Setup&quot;);

  if (!_check_input)
    executeExecutioner();
  else
  {
    errorCheck();
    // Output to stderr, so it is easier for peacock to get the result
    Moose::err &lt;&lt; &quot;Syntax OK&quot; &lt;&lt; std::endl;
  }

  Moose::perf_log.pop(&quot;Full Runtime&quot;, &quot;Application&quot;);
}

void
MooseApp::setOutputPosition(Point p)
{
  _output_position_set = true;
  _output_position = p;
  _output_warehouse.meshChanged();

  if (_executioner.get() != NULL)
    _executioner-&gt;parentOutputPositionChanged();
}

std::list&lt;std::string&gt;
MooseApp::getCheckpointDirectories() const
{
  // Storage for the directory names
  std::list&lt;std::string&gt; checkpoint_dirs;

  // Extract the CommonOutputAction
  const auto &amp; common_actions = _action_warehouse.getActionListByName(&quot;common_output&quot;);
  mooseAssert(common_actions.size() == 1, &quot;Should be only one common_output Action&quot;);

  const Action * common = *common_actions.begin();

  // If file_base is set in CommonOutputAction, add this file to the list of potential checkpoint
  // files
  if (common-&gt;isParamValid(&quot;file_base&quot;))
    checkpoint_dirs.push_back(common-&gt;getParam&lt;std::string&gt;(&quot;file_base&quot;) + &quot;_cp&quot;);
  // Case for normal application or master in a Multiapp setting
  else if (getOutputFileBase().empty())
    checkpoint_dirs.push_back(FileOutput::getOutputFileBase(*this, &quot;_out_cp&quot;));
  // Case for a sub app in a Multiapp setting
  else
    checkpoint_dirs.push_back(getOutputFileBase() + &quot;_cp&quot;);

  // Add the directories from any existing checkpoint objects
  const auto &amp; actions = _action_warehouse.getActionListByName(&quot;add_output&quot;);
  for (const auto &amp; action : actions)
  {
    // Get the parameters from the MooseObjectAction
    MooseObjectAction * moose_object_action = static_cast&lt;MooseObjectAction *&gt;(action);
    const InputParameters &amp; params = moose_object_action-&gt;getObjectParams();

    // Loop through the actions and add the necessary directories to the list to check
    if (moose_object_action-&gt;getParam&lt;std::string&gt;(&quot;type&quot;) == &quot;Checkpoint&quot;)
    {
      if (params.isParamValid(&quot;file_base&quot;))
        checkpoint_dirs.push_back(common-&gt;getParam&lt;std::string&gt;(&quot;file_base&quot;) + &quot;_cp&quot;);
      else
      {
        std::ostringstream oss;
        oss &lt;&lt; &quot;_&quot; &lt;&lt; action-&gt;name() &lt;&lt; &quot;_cp&quot;;
        checkpoint_dirs.push_back(FileOutput::getOutputFileBase(*this, oss.str()));
      }
    }
  }

  return checkpoint_dirs;
}

std::list&lt;std::string&gt;
MooseApp::getCheckpointFiles() const
{
  auto checkpoint_dirs = getCheckpointDirectories();
  return MooseUtils::getFilesInDirs(checkpoint_dirs);
}

void
MooseApp::setStartTime(const Real time)
{
  _start_time_set = true;
  _start_time = time;
}

std::string
MooseApp::getFileName(bool stripLeadingPath) const
{
  return _parser.getFileName(stripLeadingPath);
}

OutputWarehouse &amp;
MooseApp::getOutputWarehouse()
{
  return _output_warehouse;
}

std::string
MooseApp::appNameToLibName(const std::string &amp; app_name) const
{
  std::string library_name(app_name);

  // Strip off the App part (should always be the last 3 letters of the name)
  size_t pos = library_name.find(&quot;App&quot;);
  if (pos != library_name.length() - 3)
    mooseError(&quot;Invalid application name: &quot;, library_name);
  library_name.erase(pos);

  // Now get rid of the camel case, prepend lib, and append the method and suffix
  return std::string(&quot;lib&quot;) + MooseUtils::camelCaseToUnderscore(library_name) + '-' +
         QUOTE(METHOD) + &quot;.la&quot;;
}

std::string
MooseApp::libNameToAppName(const std::string &amp; library_name) const
{
  std::string app_name(library_name);

  // Strip off the leading &quot;lib&quot; and trailing &quot;.la&quot;
  if (pcrecpp::RE(&quot;lib(.+?)(?:-\\w+)?\\.la&quot;).Replace(&quot;\\1&quot;, &amp;app_name) == 0)
    mooseError(&quot;Invalid library name: &quot;, app_name);

  return MooseUtils::underscoreToCamelCase(app_name, true);
}

void
MooseApp::registerRestartableData(std::string name,
                                  std::unique_ptr&lt;RestartableDataValue&gt; data,
                                  THREAD_ID tid)
{
  auto &amp; restartable_data = _restartable_data[tid];
  auto insert_pair = moose_try_emplace(restartable_data, name, std::move(data));

  if (!insert_pair.second)
    mooseError(&quot;Attempted to declare restartable twice with the same name: &quot;, name);
}

void
MooseApp::dynamicAppRegistration(const std::string &amp; app_name,
                                 std::string library_path,
                                 const std::string &amp; library_name)
{
  Parameters params;
  params.set&lt;std::string&gt;(&quot;app_name&quot;) = app_name;
  params.set&lt;RegistrationType&gt;(&quot;reg_type&quot;) = APPLICATION;
  params.set&lt;std::string&gt;(&quot;registration_method&quot;) = app_name + &quot;__registerApps&quot;;
  params.set&lt;std::string&gt;(&quot;library_path&quot;) = library_path;
  params.set&lt;std::string&gt;(&quot;library_name&quot;) = library_name;

  dynamicRegistration(params);

  // At this point the application should be registered so check it
  if (!AppFactory::instance().isRegistered(app_name))
  {
    std::ostringstream oss;
    std::set&lt;std::string&gt; paths = getLoadedLibraryPaths();

    oss &lt;&lt; &quot;Unable to locate library for \&quot;&quot; &lt;&lt; app_name
        &lt;&lt; &quot;\&quot;.\nWe attempted to locate the library \&quot;&quot; &lt;&lt; appNameToLibName(app_name)
        &lt;&lt; &quot;\&quot; in the following paths:\n\t&quot;;
    std::copy(paths.begin(), paths.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;\n\t&quot;));
    oss &lt;&lt; &quot;\n\nMake sure you have compiled the library and either set the \&quot;library_path\&quot; &quot;
           &quot;variable &quot;
        &lt;&lt; &quot;in your input file or exported \&quot;MOOSE_LIBRARY_PATH\&quot;.\n&quot;
        &lt;&lt; &quot;Compiled in debug mode to see the list of libraries checked for dynamic loading &quot;
           &quot;methods.&quot;;
    mooseError(oss.str());
  }
}

void
MooseApp::dynamicObjectRegistration(const std::string &amp; app_name,
                                    Factory * factory,
                                    std::string library_path,
                                    const std::string &amp; library_name)
{
  Parameters params;
  params.set&lt;std::string&gt;(&quot;app_name&quot;) = app_name;
  params.set&lt;RegistrationType&gt;(&quot;reg_type&quot;) = OBJECT;
  params.set&lt;std::string&gt;(&quot;registration_method&quot;) = app_name + &quot;__registerObjects&quot;;
  params.set&lt;std::string&gt;(&quot;library_path&quot;) = library_path;
  params.set&lt;std::string&gt;(&quot;library_name&quot;) = library_name;

  params.set&lt;Factory *&gt;(&quot;factory&quot;) = factory;

  dynamicRegistration(params);
}

void
MooseApp::dynamicSyntaxAssociation(const std::string &amp; app_name,
                                   Syntax * syntax,
                                   ActionFactory * action_factory,
                                   std::string library_path,
                                   const std::string &amp; library_name)
{
  Parameters params;
  params.set&lt;std::string&gt;(&quot;app_name&quot;) = app_name;
  params.set&lt;RegistrationType&gt;(&quot;reg_type&quot;) = SYNTAX;
  params.set&lt;std::string&gt;(&quot;registration_method&quot;) = app_name + &quot;__associateSyntax&quot;;
  params.set&lt;std::string&gt;(&quot;library_path&quot;) = library_path;
  params.set&lt;std::string&gt;(&quot;library_name&quot;) = library_name;

  params.set&lt;Syntax *&gt;(&quot;syntax&quot;) = syntax;
  params.set&lt;ActionFactory *&gt;(&quot;action_factory&quot;) = action_factory;

  dynamicRegistration(params);
}

void
MooseApp::dynamicRegistration(const Parameters &amp; params)
{
  std::string library_name;
  // was library name provided by the user?
  if (params.get&lt;std::string&gt;(&quot;library_name&quot;).empty())
    library_name = appNameToLibName(params.get&lt;std::string&gt;(&quot;app_name&quot;));
  else
    library_name = params.get&lt;std::string&gt;(&quot;library_name&quot;);

  // Create a vector of paths that we can search inside for libraries
  std::vector&lt;std::string&gt; paths;

  std::string library_path = params.get&lt;std::string&gt;(&quot;library_path&quot;);

  if (library_path != &quot;&quot;)
    MooseUtils::tokenize(library_path, paths, 1, &quot;:&quot;);

  char * moose_lib_path_env = std::getenv(&quot;MOOSE_LIBRARY_PATH&quot;);
  if (moose_lib_path_env)
  {
    std::string moose_lib_path(moose_lib_path_env);
    std::vector&lt;std::string&gt; tmp_paths;

    MooseUtils::tokenize(moose_lib_path, tmp_paths, 1, &quot;:&quot;);

    // merge the two vectors together (all possible search paths)
    paths.insert(paths.end(), tmp_paths.begin(), tmp_paths.end());
  }

  // Attempt to dynamically load the library
  for (const auto &amp; path : paths)
    if (MooseUtils::checkFileReadable(path + '/' + library_name, false, false))
      loadLibraryAndDependencies(path + '/' + library_name, params);
    else
      mooseWarning(&quot;Unable to open library file \&quot;&quot;,
                   path + '/' + library_name,
                   &quot;\&quot;. Double check for spelling errors.&quot;);
}

void
MooseApp::loadLibraryAndDependencies(const std::string &amp; library_filename,
                                     const Parameters &amp; params)
{
  std::string line;
  std::string dl_lib_filename;

  // This RE looks for absolute path libtool filenames (i.e. begins with a slash and ends with a
  // .la)
  pcrecpp::RE re_deps(&quot;(/\\S*\\.la)&quot;);

  std::ifstream handle(library_filename.c_str());
  if (handle.is_open())
  {
    while (std::getline(handle, line))
    {
      // Look for the system dependent dynamic library filename to open
      if (line.find(&quot;dlname=&quot;) != std::string::npos)
        // Magic numbers are computed from length of this string &quot;dlname=' and line minus that
        // string plus quotes&quot;
        dl_lib_filename = line.substr(8, line.size() - 9);

      if (line.find(&quot;dependency_libs=&quot;) != std::string::npos)
      {
        pcrecpp::StringPiece input(line);
        pcrecpp::StringPiece depend_library;
        while (re_deps.FindAndConsume(&amp;input, &amp;depend_library))
          // Recurse here to load dependent libraries in depth-first order
          loadLibraryAndDependencies(depend_library.as_string(), params);

        // There's only one line in the .la file containing the dependency libs so break after
        // finding it
        break;
      }
    }
    handle.close();
  }

  std::string registration_method_name = params.get&lt;std::string&gt;(&quot;registration_method&quot;);
  // Time to load the library, First see if we've already loaded this particular dynamic library
  if (_lib_handles.find(std::make_pair(library_filename, registration_method_name)) ==
          _lib_handles.end() &amp;&amp; // make sure we haven't already loaded this library
      dl_lib_filename != &quot;&quot;) // AND make sure we have a library name (we won't for static linkage)
  {
    std::pair&lt;std::string, std::string&gt; lib_name_parts =
        MooseUtils::splitFileName(library_filename);

    // Assemble the actual filename using the base path of the *.la file and the dl_lib_filename
    std::string dl_lib_full_path = lib_name_parts.first + '/' + dl_lib_filename;

#ifdef LIBMESH_HAVE_DLOPEN
    void * handle = dlopen(dl_lib_full_path.c_str(), RTLD_LAZY);
#else
    void * handle = NULL;
#endif

    if (!handle)
      mooseError(&quot;Cannot open library: &quot;, dl_lib_full_path.c_str(), &quot;\n&quot;);

// get the pointer to the method in the library.  The dlsym()
// function returns a null pointer if the symbol cannot be found,
// we also explicitly set the pointer to NULL if dlsym is not
// available.
#ifdef LIBMESH_HAVE_DLOPEN
    void * registration_method = dlsym(handle, registration_method_name.c_str());
#else
    void * registration_method = NULL;
#endif

    if (!registration_method)
    {
// We found a dynamic library that doesn't have a dynamic
// registration method in it. This shouldn't be an error, so
// we'll just move on.
#ifdef DEBUG
      mooseWarning(&quot;Unable to find extern \&quot;C\&quot; method \&quot;&quot;,
                   registration_method_name,
                   &quot;\&quot; in library: &quot;,
                   dl_lib_full_path,
                   &quot;.\n&quot;,
                   &quot;This doesn't necessarily indicate an error condition unless you believe that &quot;
                   &quot;the method should exist in that library.\n&quot;);
#endif

#ifdef LIBMESH_HAVE_DLOPEN
      dlclose(handle);
#endif
    }
    else // registration_method is valid!
    {
      // TODO: Look into cleaning this up
      switch (params.get&lt;RegistrationType&gt;(&quot;reg_type&quot;))
      {
        case APPLICATION:
        {
          typedef void (*register_app_t)();
          register_app_t * reg_ptr = reinterpret_cast&lt;register_app_t *&gt;(&amp;registration_method);
          (*reg_ptr)();
          break;
        }
        case OBJECT:
        {
          typedef void (*register_app_t)(Factory *);
          register_app_t * reg_ptr = reinterpret_cast&lt;register_app_t *&gt;(&amp;registration_method);
          (*reg_ptr)(params.get&lt;Factory *&gt;(&quot;factory&quot;));
          break;
        }
        case SYNTAX:
        {
          typedef void (*register_app_t)(Syntax *, ActionFactory *);
          register_app_t * reg_ptr = reinterpret_cast&lt;register_app_t *&gt;(&amp;registration_method);
          (*reg_ptr)(params.get&lt;Syntax *&gt;(&quot;syntax&quot;), params.get&lt;ActionFactory *&gt;(&quot;action_factory&quot;));
          break;
        }
        default:
          mooseError(&quot;Unhandled RegistrationType&quot;);
      }

      // Store the handle so we can close it later
      _lib_handles.insert(
          std::make_pair(std::make_pair(library_filename, registration_method_name), handle));
    }
  }
}

std::set&lt;std::string&gt;
MooseApp::getLoadedLibraryPaths() const
{
  // Return the paths but not the open file handles
  std::set&lt;std::string&gt; paths;
  for (const auto &amp; it : _lib_handles)
    paths.insert(it.first.first);

  return paths;
}

InputParameterWarehouse &amp;
MooseApp::getInputParameterWarehouse()
{
  return *_input_parameter_warehouse;
}

std::string
MooseApp::header() const
{
  return std::string(&quot;&quot;);
}

void
MooseApp::addMeshModifier(const std::string &amp; modifier_name,
                          const std::string &amp; name,
                          InputParameters parameters)
{
  std::shared_ptr&lt;MeshModifier&gt; mesh_modifier =
      _factory.create&lt;MeshModifier&gt;(modifier_name, name, parameters);

  _mesh_modifiers.insert(std::make_pair(MooseUtils::shortName(name), mesh_modifier));
}

const MeshModifier &amp;
MooseApp::getMeshModifier(const std::string &amp; name) const
{
  return *_mesh_modifiers.find(MooseUtils::shortName(name))-&gt;second.get();
}

std::vector&lt;std::string&gt;
MooseApp::getMeshModifierNames() const
{
  std::vector&lt;std::string&gt; names;
  for (auto &amp; pair : _mesh_modifiers)
    names.push_back(pair.first);
  return names;
}

void
MooseApp::executeMeshModifiers()
{
  if (!_mesh_modifiers.empty())
  {
    DependencyResolver&lt;std::shared_ptr&lt;MeshModifier&gt;&gt; resolver;

    // Add all of the dependencies into the resolver and sort them
    for (const auto &amp; it : _mesh_modifiers)
    {
      // Make sure an item with no dependencies comes out too!
      resolver.addItem(it.second);

      std::vector&lt;std::string&gt; &amp; modifiers = it.second-&gt;getDependencies();
      for (const auto &amp; depend_name : modifiers)
      {
        auto depend_it = _mesh_modifiers.find(depend_name);

        if (depend_it == _mesh_modifiers.end())
          mooseError(&quot;The MeshModifier \&quot;&quot;,
                     depend_name,
                     &quot;\&quot; was not created, did you make a &quot;
                     &quot;spelling mistake or forget to include it &quot;
                     &quot;in your input file?&quot;);

        resolver.insertDependency(it.second, depend_it-&gt;second);
      }
    }

    const auto &amp; ordered_modifiers = resolver.getSortedValues();

    if (ordered_modifiers.size())
    {
      MooseMesh * mesh = _action_warehouse.mesh().get();
      MooseMesh * displaced_mesh = _action_warehouse.displacedMesh().get();

      // Run the MeshModifiers in the proper order
      for (const auto &amp; modifier : ordered_modifiers)
        modifier-&gt;modifyMesh(mesh, displaced_mesh);

      /**
       * Set preparation flag after modifers are run. The final preparation
       * will be handled by the SetupMeshComplete Action.
       */
      mesh-&gt;prepared(false);
      if (displaced_mesh)
        displaced_mesh-&gt;prepared(false);
    }
  }
}

void
MooseApp::clearMeshModifiers()
{
  _mesh_modifiers.clear();
}

void
MooseApp::setRestart(const bool &amp; value)
{
  _restart = value;

  std::shared_ptr&lt;FEProblemBase&gt; fe_problem = _action_warehouse.problemBase();
}

void
MooseApp::setRecover(const bool &amp; value)
{
  _recover = value;
}

void
MooseApp::restoreCachedBackup()
{
  if (!_cached_backup.get())
    mooseError(&quot;No cached Backup to restore!&quot;);

  restore(_cached_backup, isRestarting());

  // Release our hold on this Backup
  _cached_backup.reset();
}

void
MooseApp::createMinimalApp()
{
  // SetupMeshAction (setup_mesh)
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;SetupMeshAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;GeneratedMesh&quot;;
    action_params.set&lt;std::string&gt;(&quot;task&quot;) = &quot;setup_mesh&quot;;

    // Create The Action
    std::shared_ptr&lt;MooseObjectAction&gt; action = std::static_pointer_cast&lt;MooseObjectAction&gt;(
        _action_factory.create(&quot;SetupMeshAction&quot;, &quot;Mesh&quot;, action_params));

    // Set the object parameters
    InputParameters &amp; params = action-&gt;getObjectParams();
    params.set&lt;MooseEnum&gt;(&quot;dim&quot;) = &quot;1&quot;;
    params.set&lt;unsigned int&gt;(&quot;nx&quot;) = 1;

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // SetupMeshAction (init_mesh)
  {
    // Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;SetupMeshAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;GeneratedMesh&quot;;
    action_params.set&lt;std::string&gt;(&quot;task&quot;) = &quot;init_mesh&quot;;

    // Build the action
    std::shared_ptr&lt;Action&gt; action =
        _action_factory.create(&quot;SetupMeshAction&quot;, &quot;Mesh&quot;, action_params);
    _action_warehouse.addActionBlock(action);
  }

  // Executioner
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CreateExecutionerAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;Transient&quot;;

    // Create the action
    std::shared_ptr&lt;MooseObjectAction&gt; action = std::static_pointer_cast&lt;MooseObjectAction&gt;(
        _action_factory.create(&quot;CreateExecutionerAction&quot;, &quot;Executioner&quot;, action_params));

    // Set the object parameters
    InputParameters &amp; params = action-&gt;getObjectParams();
    params.set&lt;unsigned int&gt;(&quot;num_steps&quot;) = 1;
    params.set&lt;Real&gt;(&quot;dt&quot;) = 1;

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Problem
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CreateProblemAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;FEProblem&quot;;

    // Create the action
    std::shared_ptr&lt;MooseObjectAction&gt; action = std::static_pointer_cast&lt;MooseObjectAction&gt;(
        _action_factory.create(&quot;CreateProblemAction&quot;, &quot;Problem&quot;, action_params));

    // Set the object parameters
    InputParameters &amp; params = action-&gt;getObjectParams();
    params.set&lt;bool&gt;(&quot;solve&quot;) = false;

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Outputs
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CommonOutputAction&quot;);
    action_params.set&lt;bool&gt;(&quot;console&quot;) = false;

    // Create action
    std::shared_ptr&lt;Action&gt; action =
        _action_factory.create(&quot;CommonOutputAction&quot;, &quot;Outputs&quot;, action_params);

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  _action_warehouse.build();
}

void
MooseApp::addExecFlag(const ExecFlagType &amp; flag)
{
  if (flag.id() == MooseEnumItem::INVALID_ID)
  {
    // It is desired that users when creating ExecFlagTypes should not worry about needing
    // to assign a name and an ID. However, the ExecFlagTypes created by users are global constants
    // and the ID to be assigned can't be known at construction time of this global constant, it is
    // only known when it is added to this object (ExecFlagEnum). Therefore, this const cast allows
    // the ID to be set after construction. This was the lesser of two evils: const_cast or
    // friend class with mutable members.
    ExecFlagType &amp; non_const_flag = const_cast&lt;ExecFlagType &amp;&gt;(flag);
    non_const_flag.setID(_execute_flags.getNextValidID());
  }
  _execute_flags.addAvailableFlags(flag);
}

bool
MooseApp::hasRelationshipManager(const std::string &amp; name) const
{
  return std::find_if(_relationship_managers.begin(),
                      _relationship_managers.end(),
                      [&amp;name](const std::shared_ptr&lt;RelationshipManager&gt; &amp; rm) {
                        return rm-&gt;name() == name;
                      }) != _relationship_managers.end();
}

void
MooseApp::addRelationshipManager(std::shared_ptr&lt;RelationshipManager&gt; relationship_manager)
{
  auto name = relationship_manager-&gt;name();
  if (hasRelationshipManager(name))
    mooseError(&quot;Duplicate RelationshipManager added: \&quot;&quot;, name, &quot;\&quot;&quot;);

  _relationship_managers.emplace_back(relationship_manager);
}

void
MooseApp::attachRelationshipManagers(Moose::RelationshipManagerType rm_type)
{
  for (auto &amp; rm : _relationship_managers)
    rm-&gt;attachRelationshipManagers(rm_type);
}

std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;
MooseApp::getRelationshipManagerInfo()
{
  std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; info_strings;
  info_strings.reserve(_relationship_managers.size());

  for (const auto &amp; rm : _relationship_managers)
  {
    auto info = rm-&gt;getInfo();
    if (info.size())
      info_strings.emplace_back(std::make_pair(Moose::stringify(rm-&gt;getType()), info));
  }

  return info_strings;
}
</code></pre></div></div><div id="ff2a6c40-21c6-4d26-adc3-e20c78a8d072" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/src/outputs/Output.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Standard includes
#include &lt;math.h&gt;

// MOOSE includes
#include &quot;Output.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Postprocessor.h&quot;
#include &quot;Restartable.h&quot;
#include &quot;FileMesh.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Console.h&quot;

#include &quot;libmesh/equation_systems.h&quot;

template &lt;&gt;
InputParameters
validParams&lt;Output&gt;()
{
  // Get the parameters from the parent object
  InputParameters params = validParams&lt;MooseObject&gt;();
  params += validParams&lt;SetupInterface&gt;();

  // Displaced Mesh options
  params.addParam&lt;bool&gt;(
      &quot;use_displaced&quot;, false, &quot;Enable/disable the use of the displaced mesh for outputting&quot;);

  // Output intervals and timing
  params.addParam&lt;unsigned int&gt;(
      &quot;interval&quot;, 1, &quot;The interval at which time steps are output to the solution file&quot;);
  params.addParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;,
                                     &quot;Times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;bool&gt;(&quot;sync_only&quot;, false, &quot;Only export results at sync times&quot;);
  params.addParam&lt;Real&gt;(&quot;start_time&quot;, &quot;Time at which this output object begins to operate&quot;);
  params.addParam&lt;Real&gt;(&quot;end_time&quot;, &quot;Time at which this output object stop operating&quot;);
  params.addParam&lt;int&gt;(&quot;start_step&quot;, &quot;Time step at which this output object begins to operate&quot;);
  params.addParam&lt;int&gt;(&quot;end_step&quot;, &quot;Time step at which this output object stop operating&quot;);
  params.addParam&lt;Real&gt;(
      &quot;time_tolerance&quot;, 1e-14, &quot;Time tolerance utilized checking start and end times&quot;);

  // Update the 'execute_on' input parameter for output
  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());

  // Add ability to append to the 'execute_on' list
  params.addParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;, exec_enum, exec_enum.getDocString());
  params.set&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;).clear();

  // 'Timing' group
  params.addParamNamesToGroup(&quot;time_tolerance interval sync_times sync_only start_time end_time &quot;,
                              &quot;Timing&quot;);

  // Add a private parameter for indicating if it was created with short-cut syntax
  params.addPrivateParam&lt;bool&gt;(&quot;_built_by_moose&quot;, false);

  // Register this class as base class
  params.declareControllable(&quot;enable&quot;);
  params.registerBase(&quot;Output&quot;);

  return params;
}

MultiMooseEnum
Output::getExecuteOptions(std::string default_type)
{
  // TODO: ExecFlagType
  ::mooseDeprecated(&quot;This version 'getExecuteOptions' was replaced by the &quot;
                    &quot;Output::getDefaultExecFlagEnum() static function.&quot;);
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  exec_enum = default_type;
  return exec_enum;
}

ExecFlagEnum
Output::getDefaultExecFlagEnum()
{
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  return exec_enum;
}

Output::Output(const InputParameters &amp; parameters)
  : MooseObject(parameters),
    Restartable(this, &quot;Output&quot;),
    MeshChangedInterface(parameters),
    SetupInterface(this),
    _problem_ptr(getParam&lt;FEProblemBase *&gt;(&quot;_fe_problem_base&quot;)),
    _transient(_problem_ptr-&gt;isTransient()),
    _use_displaced(getParam&lt;bool&gt;(&quot;use_displaced&quot;)),
    _es_ptr(nullptr),
    _mesh_ptr(nullptr),
    _execute_on(getParam&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;)),
    _time(_problem_ptr-&gt;time()),
    _time_old(_problem_ptr-&gt;timeOld()),
    _t_step(_problem_ptr-&gt;timeStep()),
    _dt(_problem_ptr-&gt;dt()),
    _dt_old(_problem_ptr-&gt;dtOld()),
    _num(0),
    _interval(getParam&lt;unsigned int&gt;(&quot;interval&quot;)),
    _sync_times(std::set&lt;Real&gt;(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).begin(),
                               getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).end())),
    _start_time(isParamValid(&quot;start_time&quot;) ? getParam&lt;Real&gt;(&quot;start_time&quot;)
                                           : std::numeric_limits&lt;Real&gt;::lowest()),
    _end_time(isParamValid(&quot;end_time&quot;) ? getParam&lt;Real&gt;(&quot;end_time&quot;)
                                       : std::numeric_limits&lt;Real&gt;::max()),
    _start_step(isParamValid(&quot;start_step&quot;) ? getParam&lt;int&gt;(&quot;start_step&quot;)
                                           : std::numeric_limits&lt;int&gt;::lowest()),
    _end_step(isParamValid(&quot;end_step&quot;) ? getParam&lt;int&gt;(&quot;end_step&quot;)
                                       : std::numeric_limits&lt;int&gt;::max()),
    _t_tol(getParam&lt;Real&gt;(&quot;time_tolerance&quot;)),
    _sync_only(getParam&lt;bool&gt;(&quot;sync_only&quot;)),
    _initialized(false),
    _allow_output(true),
    _is_advanced(false),
    _advanced_execute_on(_execute_on, parameters)
{
  if (_use_displaced)
  {
    std::shared_ptr&lt;DisplacedProblem&gt; dp = _problem_ptr-&gt;getDisplacedProblem();
    if (dp != nullptr)
    {
      _es_ptr = &amp;dp-&gt;es();
      _mesh_ptr = &amp;dp-&gt;mesh();
    }
    else
    {
      mooseWarning(
          name(),
          &quot;: Parameter 'use_displaced' ignored, there is no displaced problem in your simulation.&quot;);
      _es_ptr = &amp;_problem_ptr-&gt;es();
      _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
    }
  }
  else
  {
    _es_ptr = &amp;_problem_ptr-&gt;es();
    _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
  }

  // Apply the additional output flags
  if (isParamValid(&quot;additional_execute_on&quot;))
  {
    const ExecFlagEnum &amp; add = getParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;);
    for (auto &amp; me : add)
      _execute_on.push_back(me);
  }
}

void
Output::initialSetup()
{
  _initialized = true;
}

void
Output::solveSetup()
{
}

void
Output::outputStep(const ExecFlagType &amp; type)
{
  // Output is not allowed
  if (!_allow_output &amp;&amp; type != EXEC_FORCED)
    return;

  // If recovering disable output of initial condition, it was already output
  if (type == EXEC_INITIAL &amp;&amp; _app.isRecovering())
    return;

  // Return if the current output is not on the desired interval
  if (type != EXEC_FINAL &amp;&amp; !onInterval())
    return;

  // Call the output method
  if (shouldOutput(type))
    output(type);
}

bool
Output::shouldOutput(const ExecFlagType &amp; type)
{
  // Note that in older versions of MOOSE, this was overloaded (unintentionally) to always return
  // true for the Console output subclass - basically ignoring execute_on options specified for
  // the console (e.g. via the input file).
  if (_execute_on.contains(type) || type == EXEC_FORCED)
    return true;
  return false;
}

bool
Output::onInterval()
{
  // The output flag to return
  bool output = false;

  // Return true if the current step on the current output interval and within the output time range
  // and within the output step range
  if (_time &gt;= _start_time &amp;&amp; _time &lt;= _end_time &amp;&amp; _t_step &gt;= _start_step &amp;&amp;
      _t_step &lt;= _end_step &amp;&amp; (_t_step % _interval) == 0)
    output = true;

  // Return false if 'sync_only' is set to true
  if (_sync_only)
    output = false;

  // If sync times are not skipped, return true if the current time is a sync_time
  if (_sync_times.find(_time) != _sync_times.end())
    output = true;

  // Return the output status
  return output;
}

Real
Output::time()
{
  if (_transient)
    return _time;
  else
    return _t_step;
}

Real
Output::timeOld()
{
  if (_transient)
    return _time_old;
  else
    return _t_step - 1;
}

Real
Output::dt()
{
  if (_transient)
    return _dt;
  else
    return 1;
}

Real
Output::dtOld()
{
  if (_transient)
    return _dt_old;
  else
    return 1;
}

int
Output::timeStep()
{
  return _t_step;
}

const MultiMooseEnum &amp;
Output::executeOn() const
{
  return _execute_on;
}

bool
Output::isAdvanced()
{
  return _is_advanced;
}

const OutputOnWarehouse &amp;
Output::advancedExecuteOn() const
{
  mooseError(&quot;The output object &quot;, name(), &quot; is not an AdvancedOutput, use isAdvanced() to check.&quot;);
  return _advanced_execute_on;
}
</code></pre></div></div><div id="b522af5d-859a-42ad-abb0-7deb9c7aaac0" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/src/outputs/Output.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Standard includes
#include &lt;math.h&gt;

// MOOSE includes
#include &quot;Output.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Postprocessor.h&quot;
#include &quot;Restartable.h&quot;
#include &quot;FileMesh.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Console.h&quot;

#include &quot;libmesh/equation_systems.h&quot;

template &lt;&gt;
InputParameters
validParams&lt;Output&gt;()
{
  // Get the parameters from the parent object
  InputParameters params = validParams&lt;MooseObject&gt;();
  params += validParams&lt;SetupInterface&gt;();

  // Displaced Mesh options
  params.addParam&lt;bool&gt;(
      &quot;use_displaced&quot;, false, &quot;Enable/disable the use of the displaced mesh for outputting&quot;);

  // Output intervals and timing
  params.addParam&lt;unsigned int&gt;(
      &quot;interval&quot;, 1, &quot;The interval at which time steps are output to the solution file&quot;);
  params.addParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;,
                                     &quot;Times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;bool&gt;(&quot;sync_only&quot;, false, &quot;Only export results at sync times&quot;);
  params.addParam&lt;Real&gt;(&quot;start_time&quot;, &quot;Time at which this output object begins to operate&quot;);
  params.addParam&lt;Real&gt;(&quot;end_time&quot;, &quot;Time at which this output object stop operating&quot;);
  params.addParam&lt;int&gt;(&quot;start_step&quot;, &quot;Time step at which this output object begins to operate&quot;);
  params.addParam&lt;int&gt;(&quot;end_step&quot;, &quot;Time step at which this output object stop operating&quot;);
  params.addParam&lt;Real&gt;(
      &quot;time_tolerance&quot;, 1e-14, &quot;Time tolerance utilized checking start and end times&quot;);

  // Update the 'execute_on' input parameter for output
  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());

  // Add ability to append to the 'execute_on' list
  params.addParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;, exec_enum, exec_enum.getDocString());
  params.set&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;).clear();

  // 'Timing' group
  params.addParamNamesToGroup(&quot;time_tolerance interval sync_times sync_only start_time end_time &quot;,
                              &quot;Timing&quot;);

  // Add a private parameter for indicating if it was created with short-cut syntax
  params.addPrivateParam&lt;bool&gt;(&quot;_built_by_moose&quot;, false);

  // Register this class as base class
  params.declareControllable(&quot;enable&quot;);
  params.registerBase(&quot;Output&quot;);

  return params;
}

MultiMooseEnum
Output::getExecuteOptions(std::string default_type)
{
  // TODO: ExecFlagType
  ::mooseDeprecated(&quot;This version 'getExecuteOptions' was replaced by the &quot;
                    &quot;Output::getDefaultExecFlagEnum() static function.&quot;);
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  exec_enum = default_type;
  return exec_enum;
}

ExecFlagEnum
Output::getDefaultExecFlagEnum()
{
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  return exec_enum;
}

Output::Output(const InputParameters &amp; parameters)
  : MooseObject(parameters),
    Restartable(this, &quot;Output&quot;),
    MeshChangedInterface(parameters),
    SetupInterface(this),
    _problem_ptr(getParam&lt;FEProblemBase *&gt;(&quot;_fe_problem_base&quot;)),
    _transient(_problem_ptr-&gt;isTransient()),
    _use_displaced(getParam&lt;bool&gt;(&quot;use_displaced&quot;)),
    _es_ptr(nullptr),
    _mesh_ptr(nullptr),
    _execute_on(getParam&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;)),
    _time(_problem_ptr-&gt;time()),
    _time_old(_problem_ptr-&gt;timeOld()),
    _t_step(_problem_ptr-&gt;timeStep()),
    _dt(_problem_ptr-&gt;dt()),
    _dt_old(_problem_ptr-&gt;dtOld()),
    _num(0),
    _interval(getParam&lt;unsigned int&gt;(&quot;interval&quot;)),
    _sync_times(std::set&lt;Real&gt;(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).begin(),
                               getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).end())),
    _start_time(isParamValid(&quot;start_time&quot;) ? getParam&lt;Real&gt;(&quot;start_time&quot;)
                                           : std::numeric_limits&lt;Real&gt;::lowest()),
    _end_time(isParamValid(&quot;end_time&quot;) ? getParam&lt;Real&gt;(&quot;end_time&quot;)
                                       : std::numeric_limits&lt;Real&gt;::max()),
    _start_step(isParamValid(&quot;start_step&quot;) ? getParam&lt;int&gt;(&quot;start_step&quot;)
                                           : std::numeric_limits&lt;int&gt;::lowest()),
    _end_step(isParamValid(&quot;end_step&quot;) ? getParam&lt;int&gt;(&quot;end_step&quot;)
                                       : std::numeric_limits&lt;int&gt;::max()),
    _t_tol(getParam&lt;Real&gt;(&quot;time_tolerance&quot;)),
    _sync_only(getParam&lt;bool&gt;(&quot;sync_only&quot;)),
    _initialized(false),
    _allow_output(true),
    _is_advanced(false),
    _advanced_execute_on(_execute_on, parameters)
{
  if (_use_displaced)
  {
    std::shared_ptr&lt;DisplacedProblem&gt; dp = _problem_ptr-&gt;getDisplacedProblem();
    if (dp != nullptr)
    {
      _es_ptr = &amp;dp-&gt;es();
      _mesh_ptr = &amp;dp-&gt;mesh();
    }
    else
    {
      mooseWarning(
          name(),
          &quot;: Parameter 'use_displaced' ignored, there is no displaced problem in your simulation.&quot;);
      _es_ptr = &amp;_problem_ptr-&gt;es();
      _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
    }
  }
  else
  {
    _es_ptr = &amp;_problem_ptr-&gt;es();
    _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
  }

  // Apply the additional output flags
  if (isParamValid(&quot;additional_execute_on&quot;))
  {
    const ExecFlagEnum &amp; add = getParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;);
    for (auto &amp; me : add)
      _execute_on.push_back(me);
  }
}

void
Output::initialSetup()
{
  _initialized = true;
}

void
Output::solveSetup()
{
}

void
Output::outputStep(const ExecFlagType &amp; type)
{
  // Output is not allowed
  if (!_allow_output &amp;&amp; type != EXEC_FORCED)
    return;

  // If recovering disable output of initial condition, it was already output
  if (type == EXEC_INITIAL &amp;&amp; _app.isRecovering())
    return;

  // Return if the current output is not on the desired interval
  if (type != EXEC_FINAL &amp;&amp; !onInterval())
    return;

  // Call the output method
  if (shouldOutput(type))
    output(type);
}

bool
Output::shouldOutput(const ExecFlagType &amp; type)
{
  // Note that in older versions of MOOSE, this was overloaded (unintentionally) to always return
  // true for the Console output subclass - basically ignoring execute_on options specified for
  // the console (e.g. via the input file).
  if (_execute_on.contains(type) || type == EXEC_FORCED)
    return true;
  return false;
}

bool
Output::onInterval()
{
  // The output flag to return
  bool output = false;

  // Return true if the current step on the current output interval and within the output time range
  // and within the output step range
  if (_time &gt;= _start_time &amp;&amp; _time &lt;= _end_time &amp;&amp; _t_step &gt;= _start_step &amp;&amp;
      _t_step &lt;= _end_step &amp;&amp; (_t_step % _interval) == 0)
    output = true;

  // Return false if 'sync_only' is set to true
  if (_sync_only)
    output = false;

  // If sync times are not skipped, return true if the current time is a sync_time
  if (_sync_times.find(_time) != _sync_times.end())
    output = true;

  // Return the output status
  return output;
}

Real
Output::time()
{
  if (_transient)
    return _time;
  else
    return _t_step;
}

Real
Output::timeOld()
{
  if (_transient)
    return _time_old;
  else
    return _t_step - 1;
}

Real
Output::dt()
{
  if (_transient)
    return _dt;
  else
    return 1;
}

Real
Output::dtOld()
{
  if (_transient)
    return _dt_old;
  else
    return 1;
}

int
Output::timeStep()
{
  return _t_step;
}

const MultiMooseEnum &amp;
Output::executeOn() const
{
  return _execute_on;
}

bool
Output::isAdvanced()
{
  return _is_advanced;
}

const OutputOnWarehouse &amp;
Output::advancedExecuteOn() const
{
  mooseError(&quot;The output object &quot;, name(), &quot; is not an AdvancedOutput, use isAdvanced() to check.&quot;);
  return _advanced_execute_on;
}
</code></pre></div></div><div id="2a6c59b3-1dd4-46a5-80fd-3ff51c8adb02" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/include/interfaces/SetupInterface.h</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifndef SETUPINTERFACE_H
#define SETUPINTERFACE_H

#include &quot;MooseTypes.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;MooseEnum.h&quot;
#include &quot;InputParameters.h&quot;

// Forward declarations
class InputParameters;
class MooseObject;
class SetupInterface;

template &lt;typename T&gt;
InputParameters validParams();

template &lt;&gt;
InputParameters validParams&lt;SetupInterface&gt;();

class SetupInterface
{
public:
  SetupInterface(const MooseObject * moose_object);
  virtual ~SetupInterface();

  /**
   * Gets called at the beginning of the simulation before this object is asked to do its job
   */
  virtual void initialSetup();

  /**
   * Gets called at the beginning of the timestep before this object is asked to do its job
   */
  virtual void timestepSetup();

  /**
   * Gets called just before the Jacobian is computed and before this object is asked to do its job
   */
  virtual void jacobianSetup();

  /**
   * Gets called just before the residual is computed and before this object is asked to do its job
   */
  virtual void residualSetup();

  /**
   * Gets called when the subdomain changes (i.e. in a Jacobian or residual loop) and before this
   * object is asked to do its job
   */
  virtual void subdomainSetup();

  /**
   * Return the execute on MultiMooseEnum for this object.
   */
  const ExecFlagEnum &amp; getExecuteOnEnum() const;

  /**
   * (DEPRECATED) Get the execution flag for the object
   * TODO: ExecFlagType
   */
  virtual const std::vector&lt;ExecFlagType&gt; &amp; execFlags() const;

  /**
   * (DEPRECATED) Build and return the execution flags as a bitfield
   * TODO: ExecFlagType
   */
  ExecFlagType execBitFlags() const;

  /**
   * (DEPRECATED) Returns the available options for the 'execute_on' input parameters
   * TODO: ExecFlagType
   * @return A MooseEnum with the available 'execute_on' options, the default is 'residual'
   */
  static ExecFlagEnum getExecuteOptions();

private:
  /// Empty ExecFlagEnum for the case when the &quot;execute_on&quot; parameter is not included. This
  /// is private because others should not be messing with it.
  ExecFlagEnum _empty_execute_enum;

protected:
  /// Execute settings for this oejct.
  const ExecFlagEnum &amp; _execute_enum;

  /// (DEPRECATED) execution flag (when is the object executed/evaluated) TODO: ExecFlagType
  const std::vector&lt;ExecFlagType&gt; _exec_flags;

  /// Reference to FEProblemBase
  const ExecFlagType &amp; _current_execute_flag;

  // FEProblemBase::addMultiApp needs to reset the execution flags
  friend class FEProblemBase;
};

#endif /* SETUPINTERFACE_H */
</code></pre></div></div><div id="d075849a-a44d-416e-accc-b92d29d29160" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/include/base/LevelSetTypes.h</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifndef LEVELSETTYPES_H
#define LEVELSETTYPES_H

#include &quot;Moose.h&quot;

namespace LevelSet
{
extern const ExecFlagType EXEC_ADAPT_MESH;
extern const ExecFlagType EXEC_COMPUTE_MARKERS;
}

#endif
</code></pre></div></div><div id="a5368b76-e3eb-4773-b49d-7d993362e356" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/src/base/LevelSetTypes.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Level set includes
#include &quot;LevelSetTypes.h&quot;

// MOOSE includes
#include &quot;MooseEnumItem.h&quot;

const ExecFlagType LevelSet::EXEC_ADAPT_MESH(&quot;ADAPT_MESH&quot;);
const ExecFlagType LevelSet::EXEC_COMPUTE_MARKERS(&quot;COMPUTE_MARKERS&quot;, 1234);
</code></pre></div></div><div id="cabc99e3-1219-4b7e-a6fb-bacee6f8710f" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/src/base/LevelSetApp.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;Moose.h&quot;
#include &quot;LevelSetApp.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;LevelSetTypes.h&quot;

template &lt;&gt;
InputParameters
validParams&lt;LevelSetApp&gt;()
{
  InputParameters params = validParams&lt;MooseApp&gt;();
  params.addClassDescription(
      &quot;Application containing object necessary to solve the level set equation.&quot;);
  return params;
}

registerKnownLabel(&quot;LevelSetApp&quot;);

LevelSetApp::LevelSetApp(InputParameters parameters) : MooseApp(parameters)
{
  srand(processor_id());

  Moose::registerObjects(_factory);
  LevelSetApp::registerObjects(_factory);

  Moose::associateSyntax(_syntax, _action_factory);
  LevelSetApp::associateSyntax(_syntax, _action_factory);

  Moose::registerExecFlags(_factory);
  LevelSetApp::registerExecFlags(_factory);
}

void
LevelSetApp::registerApps()
{
  registerApp(LevelSetApp);
}

void
LevelSetApp::registerObjects(Factory &amp; factory)
{
  Registry::registerObjectsTo(factory, {&quot;LevelSetApp&quot;});
}

void
LevelSetApp::associateSyntax(Syntax &amp; /*syntax*/, ActionFactory &amp; action_factory)
{
  Registry::registerActionsTo(action_factory, {&quot;LevelSetApp&quot;});
}

void
LevelSetApp::registerExecFlags(Factory &amp; factory)
{
  registerExecFlag(LevelSet::EXEC_ADAPT_MESH);
  registerExecFlag(LevelSet::EXEC_COMPUTE_MARKERS);
}

// Dynamic Library Entry Points - DO NOT MODIFY
extern &quot;C&quot; void
LevelSetApp__registerApps()
{
  LevelSetApp::registerApps();
}

extern &quot;C&quot; void
LevelSetApp__associateSyntax(Syntax &amp; syntax, ActionFactory &amp; action_factory)
{
  LevelSetApp::associateSyntax(syntax, action_factory);
}

extern &quot;C&quot; void
LevelSetApp__registerExecFlags(Factory &amp; factory)
{
  LevelSetApp::registerExecFlags(factory);
}

extern &quot;C&quot; void
LevelSetApp__registerObjects(Factory &amp; factory)
{
  LevelSetApp::registerObjects(factory);
}
</code></pre></div></div><div id="3b27f70f-e2a1-46bf-9a35-7e925371622d" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/src/transfers/LevelSetMeshRefinementTransfer.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LevelSetMeshRefinementTransfer.h&quot;

// MOOSE includes
#include &quot;Adaptivity.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;MooseVariable.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;LevelSetTypes.h&quot;

registerMooseObject(&quot;LevelSetApp&quot;, LevelSetMeshRefinementTransfer);

template &lt;&gt;
InputParameters
validParams&lt;LevelSetMeshRefinementTransfer&gt;()
{
  InputParameters params = validParams&lt;MultiAppCopyTransfer&gt;();
  params.addClassDescription(&quot;Transfers the mesh from the master application to the sub &quot;
                             &quot;application for the purposes of level set reinitialization problems &quot;
                             &quot;with mesh adaptivity.&quot;);
  params.set&lt;MooseEnum&gt;(&quot;direction&quot;) = &quot;TO_MULTIAPP&quot;;
  params.suppressParameter&lt;MooseEnum&gt;(&quot;direction&quot;);

  ExecFlagEnum &amp; exec = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);
  exec.addAvailableFlags(LevelSet::EXEC_ADAPT_MESH, LevelSet::EXEC_COMPUTE_MARKERS);
  exec = {LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH};
  params.set&lt;bool&gt;(&quot;check_multiapp_execute_on&quot;) = false;
  params.suppressParameter&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);

  return params;
}

LevelSetMeshRefinementTransfer::LevelSetMeshRefinementTransfer(const InputParameters &amp; parameters)
  : MultiAppCopyTransfer(parameters)
{
}

void
LevelSetMeshRefinementTransfer::initialSetup()
{
  FEProblemBase &amp; from_problem = _multi_app-&gt;problemBase();
  for (unsigned int i = 0; i &lt; _multi_app-&gt;numGlobalApps(); i++)
    if (_multi_app-&gt;hasLocalApp(i))
    {
      FEProblemBase &amp; to_problem = _multi_app-&gt;appProblemBase(i);
      MooseVariable &amp; to_var = to_problem.getStandardVariable(0, _to_var_name);
      Adaptivity &amp; adapt = to_problem.adaptivity();
      adapt.setMarkerVariableName(to_var.name());
      adapt.setCyclesPerStep(from_problem.adaptivity().getCyclesPerStep());
      adapt.init(1, 0);
      adapt.setUseNewSystem();
      adapt.setMaxHLevel(from_problem.adaptivity().getMaxHLevel());
      adapt.setAdaptivityOn(false);
    }
}

void
LevelSetMeshRefinementTransfer::execute()
{
  if (_current_execute_flag == LevelSet::EXEC_COMPUTE_MARKERS)
    MultiAppCopyTransfer::execute();

  else if (_current_execute_flag == LevelSet::EXEC_ADAPT_MESH)
  {
    for (unsigned int i = 0; i &lt; _multi_app-&gt;numGlobalApps(); i++)
      if (_multi_app-&gt;hasLocalApp(i))
      {
        FEProblemBase &amp; to_problem = _multi_app-&gt;appProblemBase(i);
        Adaptivity &amp; adapt = to_problem.adaptivity();
        adapt.setAdaptivityOn(true);
        to_problem.adaptMesh();
        adapt.setAdaptivityOn(false);
      }
  }
}
</code></pre></div></div><div id="a5a07017-99c4-4929-bd4f-e99b9ea4ad53" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/modules/level_set/src/base/LevelSetProblem.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LevelSetProblem.h&quot;
#include &quot;LevelSetTypes.h&quot;

#include &quot;MultiAppTransfer.h&quot;

registerMooseObject(&quot;LevelSetApp&quot;, LevelSetProblem);

template &lt;&gt;
InputParameters
validParams&lt;LevelSetProblem&gt;()
{
  InputParameters params = validParams&lt;FEProblem&gt;();
  params.addClassDescription(&quot;A specilized problem class that adds a custom call to &quot;
                             &quot;MultiAppTransfer execution to transfer adaptivity for the level set &quot;
                             &quot;reinitialization.&quot;);
  return params;
}

LevelSetProblem::LevelSetProblem(const InputParameters &amp; parameters) : FEProblem(parameters) {}

void
LevelSetProblem::computeMarkers()
{
  FEProblem::computeMarkers();
  setCurrentExecuteOnFlag(LevelSet::EXEC_COMPUTE_MARKERS);
  execMultiAppTransfers(LevelSet::EXEC_COMPUTE_MARKERS, MultiAppTransfer::TO_MULTIAPP);
  setCurrentExecuteOnFlag(EXEC_NONE);
}

bool
LevelSetProblem::adaptMesh()
{
  bool adapt = FEProblem::adaptMesh();
  setCurrentExecuteOnFlag(LevelSet::EXEC_ADAPT_MESH);
  execMultiAppTransfers(LevelSet::EXEC_ADAPT_MESH, MultiAppTransfer::TO_MULTIAPP);
  setCurrentExecuteOnFlag(EXEC_NONE);
  return adapt;
}
</code></pre></div></div></body></html>