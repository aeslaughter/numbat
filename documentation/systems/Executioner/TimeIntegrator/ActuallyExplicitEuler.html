<!DOCTYPE html><html><head><meta charset="UTF-8"><link media="screen,projection" href="../../../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet"></link><link href="../../../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../../../css/moose.css" type="text/css" rel="stylesheet"></link><script src="../../../../contrib/jquery/jquery.min.js" type="text/javascript"></script><script src="../../../../contrib/materialize/materialize.min.js" type="text/javascript"></script><script src="../../../../contrib/clipboard/clipboard.min.js" type="text/javascript"></script><script src="../../../../contrib/prism/prism.min.js" type="text/javascript"></script><script src="../../../../contrib/katex/katex.min.js" type="text/javascript"></script><script src="../../../../contrib/fuse/fuse.min.js" type="text/javascript"></script><script src="../../../../js/search_index.js" type="text/javascript"></script><script src="../../../../js/init.js" type="text/javascript"></script><title>ActuallyExplicitEuler|Numbat</title></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://github.com/cpgr/numbat" class="right"><img src="../../../../media/github-logo.png" class="github-mark"></img><img src="../../../../media/github-mark.png" class="github-logo"></img></a><a href="http://cpgr.github.io/numbat/" class="left moose-logo">Numbat</a><ul class="right hide-on-med-and-down" id="nav-mobile"><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="f96997c0-bc72-44e0-97f0-568f5aa5758b">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="3bd1f248-141a-47b9-9054-047c24ed1701">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="d9ce0d98-d73d-47a4-b61d-b5e60ffee6e5">Details<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="45c44a7e-266e-470c-9063-8c670cfd407a">Examples<i class="material-icons right">arrow_drop_down</i></a></li><li><a data-constrainWidth="false" href="#!" class="dropdown-button" data-activates="6fb469c6-174c-45b3-a9bb-23b3b861ced2">Manual<i class="material-icons right">arrow_drop_down</i></a></li></ul><ul class="dropdown-content" id="f96997c0-bc72-44e0-97f0-568f5aa5758b"><li><a href="../../../../getting_started.html">Installation</a></li></ul><ul class="dropdown-content" id="3bd1f248-141a-47b9-9054-047c24ed1701"><li><a href="../../../../introduction.html">Introduction</a></li><li><a href="../../../../governing_equations.html">Governing equations</a></li></ul><ul class="dropdown-content" id="d9ce0d98-d73d-47a4-b61d-b5e60ffee6e5"><li><a href="../../../../implementation.html">Implementation</a></li><li><a href="../../../../input_file_syntax.html">Input file syntax</a></li><li><a href="../../../../running_numbat.html">Running Numbat</a></li><li><a href="../../../../systems.html">Available objects</a></li></ul><ul class="dropdown-content" id="45c44a7e-266e-470c-9063-8c670cfd407a"><li><a href="../../../../example2D.html">2D</a></li><li><a href="../../../../example3D.html">3D</a></li></ul><ul class="dropdown-content" id="6fb469c6-174c-45b3-a9bb-23b3b861ced2"><li><a href="../../../../download.html">User manual</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input autocomplete="off" onkeyup="mooseSearch()" type="text" id="moose-search-box"><label for="search">http://cpgr.github.io/numbat/</label></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-action modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><span class="breadcrumb">documentation</span><a href="../.." class="breadcrumb">systems</a><a href=".." class="breadcrumb">Executioner</a><a href="." class="breadcrumb">TimeIntegrator</a><a href="ActuallyExplicitEuler.html" class="breadcrumb">ActuallyExplicitEuler</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section data-section-text="ActuallyExplicitEuler" data-section-level="1" id="329b3fd9-b8e8-44a9-b2e0-a676e8e0a8ec"><h1>ActuallyExplicitEuler</h1><p>Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver</p><section class="section scrollspy" data-section-text="Description" data-section-level="2" id="887b202c-9672-40da-99ec-4ea6977599ee"><h2>Description</h2><p><code>ActuallyExplicitEuler</code> implements true, first-order, forward Euler. It differentiates itself from <a data-position="top" href="ExplicitEuler.html" class="tooltipped" data-tooltip="ExplicitEuler.html">ExplicitEuler</a> by implementing solution methods that don't involve the "nonlinear" solver in MOOSE at all and, in the case of <code>lumped</code>, actually don't involve a linear solve at all. This makes it incredibly fast.</p></section><section class="section scrollspy" data-section-text="solve_type" data-section-level="2" id="b20df74f-e517-4804-a7a1-0e375dbb8336"><h2><code>solve_type</code></h2><p>This object has three different ways of solving. You can switch between them by using the <code>solve_type</code> parameter. The three methods are:</p><ol start="1" class="browser-default"><li><p> <code>consistent</code>: (The Default) A full mass matrix is built and used in a linear solve for the update </p></li><li><p> <code>lumped</code>: A "lumped" mass matrix is built, hand-inverted and applied to the RHS - fast, but possibly less accurate </p></li><li><p> <code>lump_preconditioned</code>: The inversion of the "lumped" mass matrix is used to precondition the <code>consistent</code> solve. Right now this is still experimental.</p></li></ol><p>All three methods are solved similarly: by solving for the update <span class="moose-katex-inline-equation" id="moose-equation-f7ae3a36-d261-47ac-b7bf-365208c161bd"><script>var element = document.getElementById("moose-equation-f7ae3a36-d261-47ac-b7bf-365208c161bd");katex.render("\\delta u", element, {displayMode:false,throwOnError:false});</script></span> then adding that to the existing solution.</p><p>Below is some more explanation of each of these <code>solve_type</code> options:</p><section data-section-text="consistent" data-section-level="3" id="0b21ccc3-3164-4d86-902f-833c70eb438c"><h3><code>consistent</code></h3><p>The <code>consistent</code> option builds a full ("consistent") "mass matrix" and uses it in a linear solve to get the update. This is done by calling <code>FEProblem::computeJacobianTag()</code> and specifying the <code>TIME</code> tag which includes all of the <code>TimeKernel</code> derived Kernels and <code>NodalBC</code> derived BoundaryConditions to compute <span class="moose-katex-inline-equation" id="moose-equation-0c970717-6186-4f11-b253-890718b3ae41"><script>var element = document.getElementById("moose-equation-0c970717-6186-4f11-b253-890718b3ae41");katex.render("\\mathbf{M}", element, {displayMode:false,throwOnError:false});</script></span>:</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">  _fe_problem.computeJacobianTag(*libmesh_system.current_local_solution, mass_matrix, _Ke_time_tag);</code></pre><a data-position="top" href="#86a33a9a-593c-42cc-a3b3-9f55d682a05e" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C">(../moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a></div></div><p>A residual computation is also completed to use as the RHS (<span class="moose-katex-inline-equation" id="moose-equation-3754e68c-c2ed-4a61-87ad-b5aa24080a66"><script>var element = document.getElementById("moose-equation-3754e68c-c2ed-4a61-87ad-b5aa24080a66");katex.render("R", element, {displayMode:false,throwOnError:false});</script></span>):</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">  _fe_problem.computeResidual(*libmesh_system.current_local_solution, _explicit_residual);</code></pre><a data-position="top" href="#fe78f65c-0d6a-4dbc-a242-5a89b46f21dc" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C">(../moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a></div></div><p>Creating the equation:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-08ba7c5e-dc26-4573-b77d-c3b949f934cf"></span><span class="moose-katex-equation-number">(1)</span><script>var element = document.getElementById("moose-equation-08ba7c5e-dc26-4573-b77d-c3b949f934cf");katex.render("\\mathbf{M} \\delta u = -R", element, {displayMode:true,throwOnError:false});</script></span></p><p>This is solved using the default linear solver from libMesh (usually PETSc... including the application of any command-line parameters specified).</p></section><section data-section-text="lumped" data-section-level="3" id="30189833-3a37-4fa8-97b6-84458b08dd5b"><h3><code>lumped</code></h3><p>The <code>lumped</code> option creates a "lumped mass matrix" to use in the solve. A lumped mass matrix is a diagonal matrix where the diagonal is the sum of all elements on the row from the original matrix.</p><p>To achieve the lumping here a matrix-vector product is performed with a vector of all ones. That creates a vector where each entry is what would be on the diagonal of the lumped mass matrix.</p><p>The inverse of a diagonal matrix is simply the reciprocal of each diagonal entry - easily applied to our vector. Then the matrix-vector product of the "inverse" lumped diagonal matrix is applied by simply doing a pointwise multiplication with the RHS.</p><p>This means that the <code>lumped</code> option actually doesn't need to solve a system of linear equations at all... making it incredibly fast. However, the use of a lumped mass matrix may lead to unacceptable phase errors.</p></section><section data-section-text="lump_preconditioned" data-section-level="3" id="fe4baa77-db1f-4273-b524-f185dbab9aa3"><h3><code>lump_preconditioned</code></h3><p>This option is the combination of the above two. The consistent mass matrix is built and used to solve... but the preconditioner is applied as simply the inverse of the lumped mass matrix. This means that solving the true (consistent) system can be done with simply using point-wise multiplications. This makes it incredibly fast and memory efficient while still accurate.</p></section></section><section class="section scrollspy" data-section-text="Advanced   Details" data-section-level="2" id="f5d17381-4901-4545-b288-c26fdd710817"><h2>Advanced Details</h2><p>A few notes on some of the implementation details of this object:</p><section data-section-text="Update   Form" data-section-level="3" id="d591c68d-a646-4207-9ce4-ab177afe9281"><h3>Update Form</h3><p>Note that even though we're doing an explicit solve we are currently doing it in "update form" similar to a single step Newton solve. This gives us good parity with the rest of MOOSE. We may want to change this in the future to make better use of the fact that the mass-matrix can be constant for a wider class of problems if we remove <code>dt</code> from it.</p></section><section data-section-text="_ones" data-section-level="3" id="a823aa6c-e585-4153-9be3-5fb869a5df23"><h3><code>_ones</code></h3><p>To get the sum of each row of the mass matrix for "lumping" purposes a vector consisting of all <code>1</code>s is used in a matrix-vector product:</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);</code></pre><a data-position="top" href="#65230ac5-93ef-43e5-bef4-afcfae240545" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C">(../moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a></div></div><p>This is actually the very same way <code>MatGetRowSum</code> is implemented in PETSc. Doing it ourselves though cuts down on vector creation/destruction and a few other bookkeeping bits.</p><p>In the future we might change this to use <code>MatGetRowSum</code> if a specialization for <code>MPI_Aij</code> format is created</p></section><section data-section-text="Time" data-section-level="3" id="2e4f77fa-5b37-4d82-b6d4-ada1087c5c9f"><h3>Time</h3><p>Time in an explicit solve must be handled carefully. When evaluating the weak form (the integral parts) of the residual time needs to actually be the "old" time (the time we are solving "from"):</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">  _fe_problem.time() = _fe_problem.timeOld();</code></pre><a data-position="top" href="#7e4ee6fe-390e-49e4-906a-129a926b1fe0" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C">(../moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a></div></div><p>However, <code>DirichletBC</code> derived boundary conditions need to use the <em></em>final** time to evaluate themselves. Think of it this way: you're integrating forward the "forces" as if evaluated from the beginning of the step... but ultimately the value on the boundary must end up being what it is supposed to be at the final time... no matter what. To achieve that we reset time to the <code>_current_time</code> in-between weak form evalution and <code>NodalBC</code> boundary condition application in <code>postResidual()</code>. <code>postResidual()</code> gets called at exactly this time to allow us to combine the <code>time</code> and <code>nontime</code> residuals into a single residual. So it's convenient to simply do:</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">  _fe_problem.time() = _current_time;</code></pre><a data-position="top" href="#b259f3df-37b2-4e6a-bd3c-cfdccca1bb9e" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C">(../moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a></div></div><p>After <code>postResidual()</code> the <code>NodalBC</code> BCs will get applied with the time at the final time for the step.</p></section><section data-section-text="meshChanged()" data-section-level="3" id="492336da-3987-4748-be83-5c833acfac69"><h3><code>meshChanged()</code></h3><p>When the mesh changes the linear solver needs to be destroyed and recreated. This is done by simply building a new one and setting it up again. This happens automatically just by "overwriting" the <code>std::unique_ptr</code> to the LinearSolver.</p></section><section data-section-text="lump_preconditioned" data-section-level="3" id="102539f1-c8ba-4e40-944d-f1825bace3d5"><h3><code>lump_preconditioned</code></h3><p>The <code>lump_preconditioned</code> option invokes a <code>LumpedPreconditioner</code> helper object:</p><div class="card"><div class="card-content"><pre style="max-height:350px;"><code class="language-cpp">class LumpedPreconditioner : public Preconditioner&lt;Real&gt;</code></pre><a data-position="top" href="#efd521ae-d4aa-45be-9e61-6c36b9f94cc5" class="tooltipped modal-trigger" data-tooltip="/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C">(../moose/framework/src/timeintegrators/ActuallyExplicitEuler.C)</a></div></div><p>This helper object simply applies the inverse of the diagonal, lumped mass-matrix as the preconditioner for the linear solve. This is extremely efficient. Note that when this option is applied you shouldn't specify any other preconditioners using command-line syntax or they will override this option. In my testing this worked well.</p></section></section><section class="section scrollspy" data-section-text="Input   Parameters" data-section-level="2" id="cdca3c37-237a-4be1-af34-a193b216337b"><h2>Input Parameters</h2><section data-details-open="open" data-section-text="Optional Parameters" data-section-level="3" id="755ad8f7-d27b-40e8-94c3-04d3f62cf0b3"><details open="open" class="moose-section-content"><ul data-collapsible="expandable" class="collapsible"><li><div class="collapsible-header"><span class="moose-parameter-name">solve_type</span><span class="moose-parameter-header-default">consistent</span><span class="moose-parameter-header-description">The way to solve the system.  A 'consistent' solve uses the full mass matrix and actually needs to use a linear solver to solve the problem.  'lumped' uses a lumped mass matrix with a simple inversion - incredibly fast but may be less accurate.  'lump_preconditioned' uses the lumped mass matrix as a preconditioner for the 'consistent' solve</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>consistent</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description"><span>Description:</span>The way to solve the system.  A 'consistent' solve uses the full mass matrix and actually needs to use a linear solver to solve the problem.  'lumped' uses a lumped mass matrix with a simple inversion - incredibly fast but may be less accurate.  'lump_preconditioned' uses the lumped mass matrix as a preconditioner for the 'consistent' solve</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section data-details-open="close" data-section-text="Advanced Parameters" data-section-level="3" id="b0160a0e-2a1d-4e0b-a3c4-d01444489946"><details class="moose-section-content"><ul data-collapsible="expandable" class="collapsible"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector<std::string></p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section></section><section class="section scrollspy" data-section-text="References" data-section-level="2" id="1b80e513-aaa2-4358-b6f7-2234918f5b8f"><h2>References</h2><ol class="moose-bibliogrpahy"></ol></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a data-delay="1000" data-position="left" href="#887b202c-9672-40da-99ec-4ea6977599ee" class="tooltipped" data-tooltip="Description">Description</a></li><li><a data-delay="1000" data-position="left" href="#b20df74f-e517-4804-a7a1-0e375dbb8336" class="tooltipped" data-tooltip="solve_type">solve_type</a></li><li><a data-delay="1000" data-position="left" href="#f5d17381-4901-4545-b288-c26fdd710817" class="tooltipped" data-tooltip="Advanced   Details">Advanced   Details</a></li><li><a data-delay="1000" data-position="left" href="#cdca3c37-237a-4be1-af34-a193b216337b" class="tooltipped" data-tooltip="Input   Parameters">Input   Parameters</a></li><li><a data-delay="1000" data-position="left" href="#1b80e513-aaa2-4358-b6f7-2234918f5b8f" class="tooltipped" data-tooltip="References">References</a></li></ul></div></div></div></div></main></div><div id="86a33a9a-593c-42cc-a3b3-9f55d682a05e" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;PetscSupport.h&quot;

// libMesh includes
#include &quot;libmesh/sparse_matrix.h&quot;
#include &quot;libmesh/nonlinear_solver.h&quot;
#include &quot;libmesh/preconditioner.h&quot;
#include &quot;libmesh/enum_convergence_flags.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

template &lt;&gt;
InputParameters
validParams&lt;ActuallyExplicitEuler&gt;()
{
  InputParameters params = validParams&lt;TimeIntegrator&gt;();

  MooseEnum solve_type(&quot;consistent lumped lump_preconditioned&quot;, &quot;consistent&quot;);

  params.addParam&lt;MooseEnum&gt;(
      &quot;solve_type&quot;,
      solve_type,
      &quot;The way to solve the system.  A 'consistent' solve uses the full mass matrix and actually &quot;
      &quot;needs to use a linear solver to solve the problem.  'lumped' uses a lumped mass matrix with &quot;
      &quot;a simple inversion - incredibly fast but may be less accurate.  'lump_preconditioned' uses &quot;
      &quot;the lumped mass matrix as a preconditioner for the 'consistent' solve&quot;);

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  return params;
}

/**
 * Helper class to apply preconditioner
 */
class LumpedPreconditioner : public Preconditioner&lt;Real&gt;
{
public:
  LumpedPreconditioner(const NumericVector&lt;Real&gt; &amp; diag_inverse)
    : Preconditioner(diag_inverse.comm()), _diag_inverse(diag_inverse)
  {
  }

  virtual void init() override
  {
    // No more initialization needed here
    _is_initialized = true;
  }

  virtual void apply(const NumericVector&lt;Real&gt; &amp; x, NumericVector&lt;Real&gt; &amp; y) override
  {
    y.pointwise_mult(_diag_inverse, x);
  }

protected:
  /// The inverse of the diagonal of the lumped matrix
  const NumericVector&lt;Real&gt; &amp; _diag_inverse;
};

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : TimeIntegrator(parameters),
    MeshChangedInterface(parameters),
    _solve_type(getParam&lt;MooseEnum&gt;(&quot;solve_type&quot;)),
    _explicit_residual(_nl.addVector(&quot;explicit_residual&quot;, false, PARALLEL)),
    _explicit_euler_update(_nl.addVector(&quot;explicit_euler_update&quot;, true, PARALLEL)),
    _mass_matrix_diag(_nl.addVector(&quot;mass_matrix_diag&quot;, false, PARALLEL))
{
  _Ke_time_tag = _fe_problem.getMatrixTagID(&quot;TIME&quot;);

  // Try to keep MOOSE from doing any nonlinear stuff
  _fe_problem.solverParams()._type = Moose::ST_LINEAR;

  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    _ones = &amp;_nl.addVector(&quot;ones&quot;, false, PARALLEL);
}

void
ActuallyExplicitEuler::initialSetup()
{
  meshChanged();
}

void
ActuallyExplicitEuler::init()
{
}

void
ActuallyExplicitEuler::preSolve()
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  _u_dot = *_solution;
  _u_dot -= _solution_old;
  _u_dot *= 1 / _dt;
  _u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::solve()
{
  auto &amp; es = _fe_problem.es();

  auto &amp; nonlinear_system = _fe_problem.getNonlinearSystemBase();

  auto &amp; libmesh_system = dynamic_cast&lt;NonlinearImplicitSystem &amp;&gt;(nonlinear_system.system());

  auto &amp; mass_matrix = *libmesh_system.matrix;

  _current_time = _fe_problem.time();

  // Set time back so that we're evaluating the interior residual at the old time
  _fe_problem.time() = _fe_problem.timeOld();

  libmesh_system.update();

  // Must compute the residual first
  _explicit_residual.zero();
  _fe_problem.computeResidual(*libmesh_system.current_local_solution, _explicit_residual);

  // The residual is on the RHS
  _explicit_residual *= -1.;

  // Compute the mass matrix
  _fe_problem.computeJacobianTag(*libmesh_system.current_local_solution, mass_matrix, _Ke_time_tag);

  // Still testing whether leaving the old update is a good idea or not
  // _explicit_euler_update = 0;

  auto converged = false;

  switch (_solve_type)
  {
    case CONSISTENT:
    {
      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    case LUMPED:
    {
      // Computes the sum of each row (lumping)
      // Note: This is actually how PETSc does it
      // It's not &quot;perfectly optimal&quot; - but it will be fast (and universal)
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);

      // &quot;Invert&quot; the diagonal mass matrix
      _mass_matrix_diag.reciprocal();

      // Multiply the inversion by the RHS
      _explicit_euler_update.pointwise_mult(_mass_matrix_diag, _explicit_residual);

      // Check for convergence by seeing if there is a nan or inf
      auto sum = _explicit_euler_update.sum();
      converged = std::isfinite(sum);

      _n_linear_iterations = 0;

      break;
    }
    case LUMP_PRECONDITIONED:
    {
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);
      _mass_matrix_diag.reciprocal();

      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    default:
      mooseError(&quot;Unknown solve_type in ActuallyExplicitEuler &quot;);
  }

  *libmesh_system.solution = nonlinear_system.solutionOld();
  *libmesh_system.solution += _explicit_euler_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = libmesh_system.get_dof_map();
  dof_map.enforce_constraints_exactly(libmesh_system, libmesh_system.solution.get());

  libmesh_system.update();

  nonlinear_system.setSolution(*libmesh_system.current_local_solution);

  libmesh_system.nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time - the boundary conditions (which is what comes next) are applied at the final time
  _fe_problem.time() = _current_time;
}

void
ActuallyExplicitEuler::meshChanged()
{
  // Can only be done after the system is inited
  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    *_ones = 1.;

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    _linear_solver = LinearSolver&lt;Number&gt;::build(comm());

  if (_solve_type == LUMP_PRECONDITIONED)
  {
    _preconditioner = libmesh_make_unique&lt;LumpedPreconditioner&gt;(_mass_matrix_diag);
    _linear_solver-&gt;attach_preconditioner(_preconditioner.get());
    _linear_solver-&gt;init();
  }

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    Moose::PetscSupport::setLinearSolverDefaults(_fe_problem, *_linear_solver);
}

bool
ActuallyExplicitEuler::checkLinearConvergence()
{
  auto reason = _linear_solver-&gt;get_converged_reason();

  switch (reason)
  {
    case CONVERGED_RTOL_NORMAL:
    case CONVERGED_ATOL_NORMAL:
    case CONVERGED_RTOL:
    case CONVERGED_ATOL:
    case CONVERGED_ITS:
    case CONVERGED_CG_NEG_CURVE:
    case CONVERGED_CG_CONSTRAINED:
    case CONVERGED_STEP_LENGTH:
    case CONVERGED_HAPPY_BREAKDOWN:
      return true;
    case DIVERGED_NULL:
    case DIVERGED_ITS:
    case DIVERGED_DTOL:
    case DIVERGED_BREAKDOWN:
    case DIVERGED_BREAKDOWN_BICG:
    case DIVERGED_NONSYMMETRIC:
    case DIVERGED_INDEFINITE_PC:
    case DIVERGED_NAN:
    case DIVERGED_INDEFINITE_MAT:
    case CONVERGED_ITERATING:
    case DIVERGED_PCSETUP_FAILED:
      return false;
    default:
      mooseError(&quot;Unknown convergence flat in ActuallyExplicitEuler&quot;);
  }
}
</code></pre></div></div><div id="fe78f65c-0d6a-4dbc-a242-5a89b46f21dc" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;PetscSupport.h&quot;

// libMesh includes
#include &quot;libmesh/sparse_matrix.h&quot;
#include &quot;libmesh/nonlinear_solver.h&quot;
#include &quot;libmesh/preconditioner.h&quot;
#include &quot;libmesh/enum_convergence_flags.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

template &lt;&gt;
InputParameters
validParams&lt;ActuallyExplicitEuler&gt;()
{
  InputParameters params = validParams&lt;TimeIntegrator&gt;();

  MooseEnum solve_type(&quot;consistent lumped lump_preconditioned&quot;, &quot;consistent&quot;);

  params.addParam&lt;MooseEnum&gt;(
      &quot;solve_type&quot;,
      solve_type,
      &quot;The way to solve the system.  A 'consistent' solve uses the full mass matrix and actually &quot;
      &quot;needs to use a linear solver to solve the problem.  'lumped' uses a lumped mass matrix with &quot;
      &quot;a simple inversion - incredibly fast but may be less accurate.  'lump_preconditioned' uses &quot;
      &quot;the lumped mass matrix as a preconditioner for the 'consistent' solve&quot;);

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  return params;
}

/**
 * Helper class to apply preconditioner
 */
class LumpedPreconditioner : public Preconditioner&lt;Real&gt;
{
public:
  LumpedPreconditioner(const NumericVector&lt;Real&gt; &amp; diag_inverse)
    : Preconditioner(diag_inverse.comm()), _diag_inverse(diag_inverse)
  {
  }

  virtual void init() override
  {
    // No more initialization needed here
    _is_initialized = true;
  }

  virtual void apply(const NumericVector&lt;Real&gt; &amp; x, NumericVector&lt;Real&gt; &amp; y) override
  {
    y.pointwise_mult(_diag_inverse, x);
  }

protected:
  /// The inverse of the diagonal of the lumped matrix
  const NumericVector&lt;Real&gt; &amp; _diag_inverse;
};

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : TimeIntegrator(parameters),
    MeshChangedInterface(parameters),
    _solve_type(getParam&lt;MooseEnum&gt;(&quot;solve_type&quot;)),
    _explicit_residual(_nl.addVector(&quot;explicit_residual&quot;, false, PARALLEL)),
    _explicit_euler_update(_nl.addVector(&quot;explicit_euler_update&quot;, true, PARALLEL)),
    _mass_matrix_diag(_nl.addVector(&quot;mass_matrix_diag&quot;, false, PARALLEL))
{
  _Ke_time_tag = _fe_problem.getMatrixTagID(&quot;TIME&quot;);

  // Try to keep MOOSE from doing any nonlinear stuff
  _fe_problem.solverParams()._type = Moose::ST_LINEAR;

  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    _ones = &amp;_nl.addVector(&quot;ones&quot;, false, PARALLEL);
}

void
ActuallyExplicitEuler::initialSetup()
{
  meshChanged();
}

void
ActuallyExplicitEuler::init()
{
}

void
ActuallyExplicitEuler::preSolve()
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  _u_dot = *_solution;
  _u_dot -= _solution_old;
  _u_dot *= 1 / _dt;
  _u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::solve()
{
  auto &amp; es = _fe_problem.es();

  auto &amp; nonlinear_system = _fe_problem.getNonlinearSystemBase();

  auto &amp; libmesh_system = dynamic_cast&lt;NonlinearImplicitSystem &amp;&gt;(nonlinear_system.system());

  auto &amp; mass_matrix = *libmesh_system.matrix;

  _current_time = _fe_problem.time();

  // Set time back so that we're evaluating the interior residual at the old time
  _fe_problem.time() = _fe_problem.timeOld();

  libmesh_system.update();

  // Must compute the residual first
  _explicit_residual.zero();
  _fe_problem.computeResidual(*libmesh_system.current_local_solution, _explicit_residual);

  // The residual is on the RHS
  _explicit_residual *= -1.;

  // Compute the mass matrix
  _fe_problem.computeJacobianTag(*libmesh_system.current_local_solution, mass_matrix, _Ke_time_tag);

  // Still testing whether leaving the old update is a good idea or not
  // _explicit_euler_update = 0;

  auto converged = false;

  switch (_solve_type)
  {
    case CONSISTENT:
    {
      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    case LUMPED:
    {
      // Computes the sum of each row (lumping)
      // Note: This is actually how PETSc does it
      // It's not &quot;perfectly optimal&quot; - but it will be fast (and universal)
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);

      // &quot;Invert&quot; the diagonal mass matrix
      _mass_matrix_diag.reciprocal();

      // Multiply the inversion by the RHS
      _explicit_euler_update.pointwise_mult(_mass_matrix_diag, _explicit_residual);

      // Check for convergence by seeing if there is a nan or inf
      auto sum = _explicit_euler_update.sum();
      converged = std::isfinite(sum);

      _n_linear_iterations = 0;

      break;
    }
    case LUMP_PRECONDITIONED:
    {
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);
      _mass_matrix_diag.reciprocal();

      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    default:
      mooseError(&quot;Unknown solve_type in ActuallyExplicitEuler &quot;);
  }

  *libmesh_system.solution = nonlinear_system.solutionOld();
  *libmesh_system.solution += _explicit_euler_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = libmesh_system.get_dof_map();
  dof_map.enforce_constraints_exactly(libmesh_system, libmesh_system.solution.get());

  libmesh_system.update();

  nonlinear_system.setSolution(*libmesh_system.current_local_solution);

  libmesh_system.nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time - the boundary conditions (which is what comes next) are applied at the final time
  _fe_problem.time() = _current_time;
}

void
ActuallyExplicitEuler::meshChanged()
{
  // Can only be done after the system is inited
  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    *_ones = 1.;

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    _linear_solver = LinearSolver&lt;Number&gt;::build(comm());

  if (_solve_type == LUMP_PRECONDITIONED)
  {
    _preconditioner = libmesh_make_unique&lt;LumpedPreconditioner&gt;(_mass_matrix_diag);
    _linear_solver-&gt;attach_preconditioner(_preconditioner.get());
    _linear_solver-&gt;init();
  }

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    Moose::PetscSupport::setLinearSolverDefaults(_fe_problem, *_linear_solver);
}

bool
ActuallyExplicitEuler::checkLinearConvergence()
{
  auto reason = _linear_solver-&gt;get_converged_reason();

  switch (reason)
  {
    case CONVERGED_RTOL_NORMAL:
    case CONVERGED_ATOL_NORMAL:
    case CONVERGED_RTOL:
    case CONVERGED_ATOL:
    case CONVERGED_ITS:
    case CONVERGED_CG_NEG_CURVE:
    case CONVERGED_CG_CONSTRAINED:
    case CONVERGED_STEP_LENGTH:
    case CONVERGED_HAPPY_BREAKDOWN:
      return true;
    case DIVERGED_NULL:
    case DIVERGED_ITS:
    case DIVERGED_DTOL:
    case DIVERGED_BREAKDOWN:
    case DIVERGED_BREAKDOWN_BICG:
    case DIVERGED_NONSYMMETRIC:
    case DIVERGED_INDEFINITE_PC:
    case DIVERGED_NAN:
    case DIVERGED_INDEFINITE_MAT:
    case CONVERGED_ITERATING:
    case DIVERGED_PCSETUP_FAILED:
      return false;
    default:
      mooseError(&quot;Unknown convergence flat in ActuallyExplicitEuler&quot;);
  }
}
</code></pre></div></div><div id="65230ac5-93ef-43e5-bef4-afcfae240545" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;PetscSupport.h&quot;

// libMesh includes
#include &quot;libmesh/sparse_matrix.h&quot;
#include &quot;libmesh/nonlinear_solver.h&quot;
#include &quot;libmesh/preconditioner.h&quot;
#include &quot;libmesh/enum_convergence_flags.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

template &lt;&gt;
InputParameters
validParams&lt;ActuallyExplicitEuler&gt;()
{
  InputParameters params = validParams&lt;TimeIntegrator&gt;();

  MooseEnum solve_type(&quot;consistent lumped lump_preconditioned&quot;, &quot;consistent&quot;);

  params.addParam&lt;MooseEnum&gt;(
      &quot;solve_type&quot;,
      solve_type,
      &quot;The way to solve the system.  A 'consistent' solve uses the full mass matrix and actually &quot;
      &quot;needs to use a linear solver to solve the problem.  'lumped' uses a lumped mass matrix with &quot;
      &quot;a simple inversion - incredibly fast but may be less accurate.  'lump_preconditioned' uses &quot;
      &quot;the lumped mass matrix as a preconditioner for the 'consistent' solve&quot;);

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  return params;
}

/**
 * Helper class to apply preconditioner
 */
class LumpedPreconditioner : public Preconditioner&lt;Real&gt;
{
public:
  LumpedPreconditioner(const NumericVector&lt;Real&gt; &amp; diag_inverse)
    : Preconditioner(diag_inverse.comm()), _diag_inverse(diag_inverse)
  {
  }

  virtual void init() override
  {
    // No more initialization needed here
    _is_initialized = true;
  }

  virtual void apply(const NumericVector&lt;Real&gt; &amp; x, NumericVector&lt;Real&gt; &amp; y) override
  {
    y.pointwise_mult(_diag_inverse, x);
  }

protected:
  /// The inverse of the diagonal of the lumped matrix
  const NumericVector&lt;Real&gt; &amp; _diag_inverse;
};

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : TimeIntegrator(parameters),
    MeshChangedInterface(parameters),
    _solve_type(getParam&lt;MooseEnum&gt;(&quot;solve_type&quot;)),
    _explicit_residual(_nl.addVector(&quot;explicit_residual&quot;, false, PARALLEL)),
    _explicit_euler_update(_nl.addVector(&quot;explicit_euler_update&quot;, true, PARALLEL)),
    _mass_matrix_diag(_nl.addVector(&quot;mass_matrix_diag&quot;, false, PARALLEL))
{
  _Ke_time_tag = _fe_problem.getMatrixTagID(&quot;TIME&quot;);

  // Try to keep MOOSE from doing any nonlinear stuff
  _fe_problem.solverParams()._type = Moose::ST_LINEAR;

  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    _ones = &amp;_nl.addVector(&quot;ones&quot;, false, PARALLEL);
}

void
ActuallyExplicitEuler::initialSetup()
{
  meshChanged();
}

void
ActuallyExplicitEuler::init()
{
}

void
ActuallyExplicitEuler::preSolve()
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  _u_dot = *_solution;
  _u_dot -= _solution_old;
  _u_dot *= 1 / _dt;
  _u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::solve()
{
  auto &amp; es = _fe_problem.es();

  auto &amp; nonlinear_system = _fe_problem.getNonlinearSystemBase();

  auto &amp; libmesh_system = dynamic_cast&lt;NonlinearImplicitSystem &amp;&gt;(nonlinear_system.system());

  auto &amp; mass_matrix = *libmesh_system.matrix;

  _current_time = _fe_problem.time();

  // Set time back so that we're evaluating the interior residual at the old time
  _fe_problem.time() = _fe_problem.timeOld();

  libmesh_system.update();

  // Must compute the residual first
  _explicit_residual.zero();
  _fe_problem.computeResidual(*libmesh_system.current_local_solution, _explicit_residual);

  // The residual is on the RHS
  _explicit_residual *= -1.;

  // Compute the mass matrix
  _fe_problem.computeJacobianTag(*libmesh_system.current_local_solution, mass_matrix, _Ke_time_tag);

  // Still testing whether leaving the old update is a good idea or not
  // _explicit_euler_update = 0;

  auto converged = false;

  switch (_solve_type)
  {
    case CONSISTENT:
    {
      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    case LUMPED:
    {
      // Computes the sum of each row (lumping)
      // Note: This is actually how PETSc does it
      // It's not &quot;perfectly optimal&quot; - but it will be fast (and universal)
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);

      // &quot;Invert&quot; the diagonal mass matrix
      _mass_matrix_diag.reciprocal();

      // Multiply the inversion by the RHS
      _explicit_euler_update.pointwise_mult(_mass_matrix_diag, _explicit_residual);

      // Check for convergence by seeing if there is a nan or inf
      auto sum = _explicit_euler_update.sum();
      converged = std::isfinite(sum);

      _n_linear_iterations = 0;

      break;
    }
    case LUMP_PRECONDITIONED:
    {
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);
      _mass_matrix_diag.reciprocal();

      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    default:
      mooseError(&quot;Unknown solve_type in ActuallyExplicitEuler &quot;);
  }

  *libmesh_system.solution = nonlinear_system.solutionOld();
  *libmesh_system.solution += _explicit_euler_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = libmesh_system.get_dof_map();
  dof_map.enforce_constraints_exactly(libmesh_system, libmesh_system.solution.get());

  libmesh_system.update();

  nonlinear_system.setSolution(*libmesh_system.current_local_solution);

  libmesh_system.nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time - the boundary conditions (which is what comes next) are applied at the final time
  _fe_problem.time() = _current_time;
}

void
ActuallyExplicitEuler::meshChanged()
{
  // Can only be done after the system is inited
  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    *_ones = 1.;

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    _linear_solver = LinearSolver&lt;Number&gt;::build(comm());

  if (_solve_type == LUMP_PRECONDITIONED)
  {
    _preconditioner = libmesh_make_unique&lt;LumpedPreconditioner&gt;(_mass_matrix_diag);
    _linear_solver-&gt;attach_preconditioner(_preconditioner.get());
    _linear_solver-&gt;init();
  }

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    Moose::PetscSupport::setLinearSolverDefaults(_fe_problem, *_linear_solver);
}

bool
ActuallyExplicitEuler::checkLinearConvergence()
{
  auto reason = _linear_solver-&gt;get_converged_reason();

  switch (reason)
  {
    case CONVERGED_RTOL_NORMAL:
    case CONVERGED_ATOL_NORMAL:
    case CONVERGED_RTOL:
    case CONVERGED_ATOL:
    case CONVERGED_ITS:
    case CONVERGED_CG_NEG_CURVE:
    case CONVERGED_CG_CONSTRAINED:
    case CONVERGED_STEP_LENGTH:
    case CONVERGED_HAPPY_BREAKDOWN:
      return true;
    case DIVERGED_NULL:
    case DIVERGED_ITS:
    case DIVERGED_DTOL:
    case DIVERGED_BREAKDOWN:
    case DIVERGED_BREAKDOWN_BICG:
    case DIVERGED_NONSYMMETRIC:
    case DIVERGED_INDEFINITE_PC:
    case DIVERGED_NAN:
    case DIVERGED_INDEFINITE_MAT:
    case CONVERGED_ITERATING:
    case DIVERGED_PCSETUP_FAILED:
      return false;
    default:
      mooseError(&quot;Unknown convergence flat in ActuallyExplicitEuler&quot;);
  }
}
</code></pre></div></div><div id="7e4ee6fe-390e-49e4-906a-129a926b1fe0" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;PetscSupport.h&quot;

// libMesh includes
#include &quot;libmesh/sparse_matrix.h&quot;
#include &quot;libmesh/nonlinear_solver.h&quot;
#include &quot;libmesh/preconditioner.h&quot;
#include &quot;libmesh/enum_convergence_flags.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

template &lt;&gt;
InputParameters
validParams&lt;ActuallyExplicitEuler&gt;()
{
  InputParameters params = validParams&lt;TimeIntegrator&gt;();

  MooseEnum solve_type(&quot;consistent lumped lump_preconditioned&quot;, &quot;consistent&quot;);

  params.addParam&lt;MooseEnum&gt;(
      &quot;solve_type&quot;,
      solve_type,
      &quot;The way to solve the system.  A 'consistent' solve uses the full mass matrix and actually &quot;
      &quot;needs to use a linear solver to solve the problem.  'lumped' uses a lumped mass matrix with &quot;
      &quot;a simple inversion - incredibly fast but may be less accurate.  'lump_preconditioned' uses &quot;
      &quot;the lumped mass matrix as a preconditioner for the 'consistent' solve&quot;);

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  return params;
}

/**
 * Helper class to apply preconditioner
 */
class LumpedPreconditioner : public Preconditioner&lt;Real&gt;
{
public:
  LumpedPreconditioner(const NumericVector&lt;Real&gt; &amp; diag_inverse)
    : Preconditioner(diag_inverse.comm()), _diag_inverse(diag_inverse)
  {
  }

  virtual void init() override
  {
    // No more initialization needed here
    _is_initialized = true;
  }

  virtual void apply(const NumericVector&lt;Real&gt; &amp; x, NumericVector&lt;Real&gt; &amp; y) override
  {
    y.pointwise_mult(_diag_inverse, x);
  }

protected:
  /// The inverse of the diagonal of the lumped matrix
  const NumericVector&lt;Real&gt; &amp; _diag_inverse;
};

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : TimeIntegrator(parameters),
    MeshChangedInterface(parameters),
    _solve_type(getParam&lt;MooseEnum&gt;(&quot;solve_type&quot;)),
    _explicit_residual(_nl.addVector(&quot;explicit_residual&quot;, false, PARALLEL)),
    _explicit_euler_update(_nl.addVector(&quot;explicit_euler_update&quot;, true, PARALLEL)),
    _mass_matrix_diag(_nl.addVector(&quot;mass_matrix_diag&quot;, false, PARALLEL))
{
  _Ke_time_tag = _fe_problem.getMatrixTagID(&quot;TIME&quot;);

  // Try to keep MOOSE from doing any nonlinear stuff
  _fe_problem.solverParams()._type = Moose::ST_LINEAR;

  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    _ones = &amp;_nl.addVector(&quot;ones&quot;, false, PARALLEL);
}

void
ActuallyExplicitEuler::initialSetup()
{
  meshChanged();
}

void
ActuallyExplicitEuler::init()
{
}

void
ActuallyExplicitEuler::preSolve()
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  _u_dot = *_solution;
  _u_dot -= _solution_old;
  _u_dot *= 1 / _dt;
  _u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::solve()
{
  auto &amp; es = _fe_problem.es();

  auto &amp; nonlinear_system = _fe_problem.getNonlinearSystemBase();

  auto &amp; libmesh_system = dynamic_cast&lt;NonlinearImplicitSystem &amp;&gt;(nonlinear_system.system());

  auto &amp; mass_matrix = *libmesh_system.matrix;

  _current_time = _fe_problem.time();

  // Set time back so that we're evaluating the interior residual at the old time
  _fe_problem.time() = _fe_problem.timeOld();

  libmesh_system.update();

  // Must compute the residual first
  _explicit_residual.zero();
  _fe_problem.computeResidual(*libmesh_system.current_local_solution, _explicit_residual);

  // The residual is on the RHS
  _explicit_residual *= -1.;

  // Compute the mass matrix
  _fe_problem.computeJacobianTag(*libmesh_system.current_local_solution, mass_matrix, _Ke_time_tag);

  // Still testing whether leaving the old update is a good idea or not
  // _explicit_euler_update = 0;

  auto converged = false;

  switch (_solve_type)
  {
    case CONSISTENT:
    {
      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    case LUMPED:
    {
      // Computes the sum of each row (lumping)
      // Note: This is actually how PETSc does it
      // It's not &quot;perfectly optimal&quot; - but it will be fast (and universal)
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);

      // &quot;Invert&quot; the diagonal mass matrix
      _mass_matrix_diag.reciprocal();

      // Multiply the inversion by the RHS
      _explicit_euler_update.pointwise_mult(_mass_matrix_diag, _explicit_residual);

      // Check for convergence by seeing if there is a nan or inf
      auto sum = _explicit_euler_update.sum();
      converged = std::isfinite(sum);

      _n_linear_iterations = 0;

      break;
    }
    case LUMP_PRECONDITIONED:
    {
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);
      _mass_matrix_diag.reciprocal();

      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    default:
      mooseError(&quot;Unknown solve_type in ActuallyExplicitEuler &quot;);
  }

  *libmesh_system.solution = nonlinear_system.solutionOld();
  *libmesh_system.solution += _explicit_euler_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = libmesh_system.get_dof_map();
  dof_map.enforce_constraints_exactly(libmesh_system, libmesh_system.solution.get());

  libmesh_system.update();

  nonlinear_system.setSolution(*libmesh_system.current_local_solution);

  libmesh_system.nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time - the boundary conditions (which is what comes next) are applied at the final time
  _fe_problem.time() = _current_time;
}

void
ActuallyExplicitEuler::meshChanged()
{
  // Can only be done after the system is inited
  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    *_ones = 1.;

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    _linear_solver = LinearSolver&lt;Number&gt;::build(comm());

  if (_solve_type == LUMP_PRECONDITIONED)
  {
    _preconditioner = libmesh_make_unique&lt;LumpedPreconditioner&gt;(_mass_matrix_diag);
    _linear_solver-&gt;attach_preconditioner(_preconditioner.get());
    _linear_solver-&gt;init();
  }

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    Moose::PetscSupport::setLinearSolverDefaults(_fe_problem, *_linear_solver);
}

bool
ActuallyExplicitEuler::checkLinearConvergence()
{
  auto reason = _linear_solver-&gt;get_converged_reason();

  switch (reason)
  {
    case CONVERGED_RTOL_NORMAL:
    case CONVERGED_ATOL_NORMAL:
    case CONVERGED_RTOL:
    case CONVERGED_ATOL:
    case CONVERGED_ITS:
    case CONVERGED_CG_NEG_CURVE:
    case CONVERGED_CG_CONSTRAINED:
    case CONVERGED_STEP_LENGTH:
    case CONVERGED_HAPPY_BREAKDOWN:
      return true;
    case DIVERGED_NULL:
    case DIVERGED_ITS:
    case DIVERGED_DTOL:
    case DIVERGED_BREAKDOWN:
    case DIVERGED_BREAKDOWN_BICG:
    case DIVERGED_NONSYMMETRIC:
    case DIVERGED_INDEFINITE_PC:
    case DIVERGED_NAN:
    case DIVERGED_INDEFINITE_MAT:
    case CONVERGED_ITERATING:
    case DIVERGED_PCSETUP_FAILED:
      return false;
    default:
      mooseError(&quot;Unknown convergence flat in ActuallyExplicitEuler&quot;);
  }
}
</code></pre></div></div><div id="b259f3df-37b2-4e6a-bd3c-cfdccca1bb9e" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;PetscSupport.h&quot;

// libMesh includes
#include &quot;libmesh/sparse_matrix.h&quot;
#include &quot;libmesh/nonlinear_solver.h&quot;
#include &quot;libmesh/preconditioner.h&quot;
#include &quot;libmesh/enum_convergence_flags.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

template &lt;&gt;
InputParameters
validParams&lt;ActuallyExplicitEuler&gt;()
{
  InputParameters params = validParams&lt;TimeIntegrator&gt;();

  MooseEnum solve_type(&quot;consistent lumped lump_preconditioned&quot;, &quot;consistent&quot;);

  params.addParam&lt;MooseEnum&gt;(
      &quot;solve_type&quot;,
      solve_type,
      &quot;The way to solve the system.  A 'consistent' solve uses the full mass matrix and actually &quot;
      &quot;needs to use a linear solver to solve the problem.  'lumped' uses a lumped mass matrix with &quot;
      &quot;a simple inversion - incredibly fast but may be less accurate.  'lump_preconditioned' uses &quot;
      &quot;the lumped mass matrix as a preconditioner for the 'consistent' solve&quot;);

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  return params;
}

/**
 * Helper class to apply preconditioner
 */
class LumpedPreconditioner : public Preconditioner&lt;Real&gt;
{
public:
  LumpedPreconditioner(const NumericVector&lt;Real&gt; &amp; diag_inverse)
    : Preconditioner(diag_inverse.comm()), _diag_inverse(diag_inverse)
  {
  }

  virtual void init() override
  {
    // No more initialization needed here
    _is_initialized = true;
  }

  virtual void apply(const NumericVector&lt;Real&gt; &amp; x, NumericVector&lt;Real&gt; &amp; y) override
  {
    y.pointwise_mult(_diag_inverse, x);
  }

protected:
  /// The inverse of the diagonal of the lumped matrix
  const NumericVector&lt;Real&gt; &amp; _diag_inverse;
};

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : TimeIntegrator(parameters),
    MeshChangedInterface(parameters),
    _solve_type(getParam&lt;MooseEnum&gt;(&quot;solve_type&quot;)),
    _explicit_residual(_nl.addVector(&quot;explicit_residual&quot;, false, PARALLEL)),
    _explicit_euler_update(_nl.addVector(&quot;explicit_euler_update&quot;, true, PARALLEL)),
    _mass_matrix_diag(_nl.addVector(&quot;mass_matrix_diag&quot;, false, PARALLEL))
{
  _Ke_time_tag = _fe_problem.getMatrixTagID(&quot;TIME&quot;);

  // Try to keep MOOSE from doing any nonlinear stuff
  _fe_problem.solverParams()._type = Moose::ST_LINEAR;

  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    _ones = &amp;_nl.addVector(&quot;ones&quot;, false, PARALLEL);
}

void
ActuallyExplicitEuler::initialSetup()
{
  meshChanged();
}

void
ActuallyExplicitEuler::init()
{
}

void
ActuallyExplicitEuler::preSolve()
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  _u_dot = *_solution;
  _u_dot -= _solution_old;
  _u_dot *= 1 / _dt;
  _u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::solve()
{
  auto &amp; es = _fe_problem.es();

  auto &amp; nonlinear_system = _fe_problem.getNonlinearSystemBase();

  auto &amp; libmesh_system = dynamic_cast&lt;NonlinearImplicitSystem &amp;&gt;(nonlinear_system.system());

  auto &amp; mass_matrix = *libmesh_system.matrix;

  _current_time = _fe_problem.time();

  // Set time back so that we're evaluating the interior residual at the old time
  _fe_problem.time() = _fe_problem.timeOld();

  libmesh_system.update();

  // Must compute the residual first
  _explicit_residual.zero();
  _fe_problem.computeResidual(*libmesh_system.current_local_solution, _explicit_residual);

  // The residual is on the RHS
  _explicit_residual *= -1.;

  // Compute the mass matrix
  _fe_problem.computeJacobianTag(*libmesh_system.current_local_solution, mass_matrix, _Ke_time_tag);

  // Still testing whether leaving the old update is a good idea or not
  // _explicit_euler_update = 0;

  auto converged = false;

  switch (_solve_type)
  {
    case CONSISTENT:
    {
      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    case LUMPED:
    {
      // Computes the sum of each row (lumping)
      // Note: This is actually how PETSc does it
      // It's not &quot;perfectly optimal&quot; - but it will be fast (and universal)
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);

      // &quot;Invert&quot; the diagonal mass matrix
      _mass_matrix_diag.reciprocal();

      // Multiply the inversion by the RHS
      _explicit_euler_update.pointwise_mult(_mass_matrix_diag, _explicit_residual);

      // Check for convergence by seeing if there is a nan or inf
      auto sum = _explicit_euler_update.sum();
      converged = std::isfinite(sum);

      _n_linear_iterations = 0;

      break;
    }
    case LUMP_PRECONDITIONED:
    {
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);
      _mass_matrix_diag.reciprocal();

      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    default:
      mooseError(&quot;Unknown solve_type in ActuallyExplicitEuler &quot;);
  }

  *libmesh_system.solution = nonlinear_system.solutionOld();
  *libmesh_system.solution += _explicit_euler_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = libmesh_system.get_dof_map();
  dof_map.enforce_constraints_exactly(libmesh_system, libmesh_system.solution.get());

  libmesh_system.update();

  nonlinear_system.setSolution(*libmesh_system.current_local_solution);

  libmesh_system.nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time - the boundary conditions (which is what comes next) are applied at the final time
  _fe_problem.time() = _current_time;
}

void
ActuallyExplicitEuler::meshChanged()
{
  // Can only be done after the system is inited
  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    *_ones = 1.;

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    _linear_solver = LinearSolver&lt;Number&gt;::build(comm());

  if (_solve_type == LUMP_PRECONDITIONED)
  {
    _preconditioner = libmesh_make_unique&lt;LumpedPreconditioner&gt;(_mass_matrix_diag);
    _linear_solver-&gt;attach_preconditioner(_preconditioner.get());
    _linear_solver-&gt;init();
  }

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    Moose::PetscSupport::setLinearSolverDefaults(_fe_problem, *_linear_solver);
}

bool
ActuallyExplicitEuler::checkLinearConvergence()
{
  auto reason = _linear_solver-&gt;get_converged_reason();

  switch (reason)
  {
    case CONVERGED_RTOL_NORMAL:
    case CONVERGED_ATOL_NORMAL:
    case CONVERGED_RTOL:
    case CONVERGED_ATOL:
    case CONVERGED_ITS:
    case CONVERGED_CG_NEG_CURVE:
    case CONVERGED_CG_CONSTRAINED:
    case CONVERGED_STEP_LENGTH:
    case CONVERGED_HAPPY_BREAKDOWN:
      return true;
    case DIVERGED_NULL:
    case DIVERGED_ITS:
    case DIVERGED_DTOL:
    case DIVERGED_BREAKDOWN:
    case DIVERGED_BREAKDOWN_BICG:
    case DIVERGED_NONSYMMETRIC:
    case DIVERGED_INDEFINITE_PC:
    case DIVERGED_NAN:
    case DIVERGED_INDEFINITE_MAT:
    case CONVERGED_ITERATING:
    case DIVERGED_PCSETUP_FAILED:
      return false;
    default:
      mooseError(&quot;Unknown convergence flat in ActuallyExplicitEuler&quot;);
  }
}
</code></pre></div></div><div id="efd521ae-d4aa-45be-9e61-6c36b9f94cc5" class="modal bottom-sheet"><div class="modal-content"><h4>/Users/gre462/Documents/MOOSE/projects/moose/framework/src/timeintegrators/ActuallyExplicitEuler.C</h4><pre><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;ActuallyExplicitEuler.h&quot;
#include &quot;NonlinearSystem.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;PetscSupport.h&quot;

// libMesh includes
#include &quot;libmesh/sparse_matrix.h&quot;
#include &quot;libmesh/nonlinear_solver.h&quot;
#include &quot;libmesh/preconditioner.h&quot;
#include &quot;libmesh/enum_convergence_flags.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ActuallyExplicitEuler);

template &lt;&gt;
InputParameters
validParams&lt;ActuallyExplicitEuler&gt;()
{
  InputParameters params = validParams&lt;TimeIntegrator&gt;();

  MooseEnum solve_type(&quot;consistent lumped lump_preconditioned&quot;, &quot;consistent&quot;);

  params.addParam&lt;MooseEnum&gt;(
      &quot;solve_type&quot;,
      solve_type,
      &quot;The way to solve the system.  A 'consistent' solve uses the full mass matrix and actually &quot;
      &quot;needs to use a linear solver to solve the problem.  'lumped' uses a lumped mass matrix with &quot;
      &quot;a simple inversion - incredibly fast but may be less accurate.  'lump_preconditioned' uses &quot;
      &quot;the lumped mass matrix as a preconditioner for the 'consistent' solve&quot;);

  params.addClassDescription(
      &quot;Implementation of Explicit/Forward Euler without invoking any of the nonlinear solver&quot;);

  return params;
}

/**
 * Helper class to apply preconditioner
 */
class LumpedPreconditioner : public Preconditioner&lt;Real&gt;
{
public:
  LumpedPreconditioner(const NumericVector&lt;Real&gt; &amp; diag_inverse)
    : Preconditioner(diag_inverse.comm()), _diag_inverse(diag_inverse)
  {
  }

  virtual void init() override
  {
    // No more initialization needed here
    _is_initialized = true;
  }

  virtual void apply(const NumericVector&lt;Real&gt; &amp; x, NumericVector&lt;Real&gt; &amp; y) override
  {
    y.pointwise_mult(_diag_inverse, x);
  }

protected:
  /// The inverse of the diagonal of the lumped matrix
  const NumericVector&lt;Real&gt; &amp; _diag_inverse;
};

ActuallyExplicitEuler::ActuallyExplicitEuler(const InputParameters &amp; parameters)
  : TimeIntegrator(parameters),
    MeshChangedInterface(parameters),
    _solve_type(getParam&lt;MooseEnum&gt;(&quot;solve_type&quot;)),
    _explicit_residual(_nl.addVector(&quot;explicit_residual&quot;, false, PARALLEL)),
    _explicit_euler_update(_nl.addVector(&quot;explicit_euler_update&quot;, true, PARALLEL)),
    _mass_matrix_diag(_nl.addVector(&quot;mass_matrix_diag&quot;, false, PARALLEL))
{
  _Ke_time_tag = _fe_problem.getMatrixTagID(&quot;TIME&quot;);

  // Try to keep MOOSE from doing any nonlinear stuff
  _fe_problem.solverParams()._type = Moose::ST_LINEAR;

  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    _ones = &amp;_nl.addVector(&quot;ones&quot;, false, PARALLEL);
}

void
ActuallyExplicitEuler::initialSetup()
{
  meshChanged();
}

void
ActuallyExplicitEuler::init()
{
}

void
ActuallyExplicitEuler::preSolve()
{
}

void
ActuallyExplicitEuler::computeTimeDerivatives()
{
  _u_dot = *_solution;
  _u_dot -= _solution_old;
  _u_dot *= 1 / _dt;
  _u_dot.close();

  _du_dot_du = 1.0 / _dt;
}

void
ActuallyExplicitEuler::solve()
{
  auto &amp; es = _fe_problem.es();

  auto &amp; nonlinear_system = _fe_problem.getNonlinearSystemBase();

  auto &amp; libmesh_system = dynamic_cast&lt;NonlinearImplicitSystem &amp;&gt;(nonlinear_system.system());

  auto &amp; mass_matrix = *libmesh_system.matrix;

  _current_time = _fe_problem.time();

  // Set time back so that we're evaluating the interior residual at the old time
  _fe_problem.time() = _fe_problem.timeOld();

  libmesh_system.update();

  // Must compute the residual first
  _explicit_residual.zero();
  _fe_problem.computeResidual(*libmesh_system.current_local_solution, _explicit_residual);

  // The residual is on the RHS
  _explicit_residual *= -1.;

  // Compute the mass matrix
  _fe_problem.computeJacobianTag(*libmesh_system.current_local_solution, mass_matrix, _Ke_time_tag);

  // Still testing whether leaving the old update is a good idea or not
  // _explicit_euler_update = 0;

  auto converged = false;

  switch (_solve_type)
  {
    case CONSISTENT:
    {
      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    case LUMPED:
    {
      // Computes the sum of each row (lumping)
      // Note: This is actually how PETSc does it
      // It's not &quot;perfectly optimal&quot; - but it will be fast (and universal)
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);

      // &quot;Invert&quot; the diagonal mass matrix
      _mass_matrix_diag.reciprocal();

      // Multiply the inversion by the RHS
      _explicit_euler_update.pointwise_mult(_mass_matrix_diag, _explicit_residual);

      // Check for convergence by seeing if there is a nan or inf
      auto sum = _explicit_euler_update.sum();
      converged = std::isfinite(sum);

      _n_linear_iterations = 0;

      break;
    }
    case LUMP_PRECONDITIONED:
    {
      mass_matrix.vector_mult(_mass_matrix_diag, *_ones);
      _mass_matrix_diag.reciprocal();

      const auto num_its_and_final_tol = _linear_solver-&gt;solve(
          mass_matrix,
          _explicit_euler_update,
          _explicit_residual,
          es.parameters.get&lt;Real&gt;(&quot;linear solver tolerance&quot;),
          es.parameters.get&lt;unsigned int&gt;(&quot;linear solver maximum iterations&quot;));

      converged = checkLinearConvergence();

      _n_linear_iterations = num_its_and_final_tol.first;

      break;
    }
    default:
      mooseError(&quot;Unknown solve_type in ActuallyExplicitEuler &quot;);
  }

  *libmesh_system.solution = nonlinear_system.solutionOld();
  *libmesh_system.solution += _explicit_euler_update;

  // Enforce contraints on the solution
  DofMap &amp; dof_map = libmesh_system.get_dof_map();
  dof_map.enforce_constraints_exactly(libmesh_system, libmesh_system.solution.get());

  libmesh_system.update();

  nonlinear_system.setSolution(*libmesh_system.current_local_solution);

  libmesh_system.nonlinear_solver-&gt;converged = converged;
}

void
ActuallyExplicitEuler::postResidual(NumericVector&lt;Number&gt; &amp; residual)
{
  residual += _Re_time;
  residual += _Re_non_time;
  residual.close();

  // Reset time - the boundary conditions (which is what comes next) are applied at the final time
  _fe_problem.time() = _current_time;
}

void
ActuallyExplicitEuler::meshChanged()
{
  // Can only be done after the system is inited
  if (_solve_type == LUMPED || _solve_type == LUMP_PRECONDITIONED)
    *_ones = 1.;

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    _linear_solver = LinearSolver&lt;Number&gt;::build(comm());

  if (_solve_type == LUMP_PRECONDITIONED)
  {
    _preconditioner = libmesh_make_unique&lt;LumpedPreconditioner&gt;(_mass_matrix_diag);
    _linear_solver-&gt;attach_preconditioner(_preconditioner.get());
    _linear_solver-&gt;init();
  }

  if (_solve_type == CONSISTENT || _solve_type == LUMP_PRECONDITIONED)
    Moose::PetscSupport::setLinearSolverDefaults(_fe_problem, *_linear_solver);
}

bool
ActuallyExplicitEuler::checkLinearConvergence()
{
  auto reason = _linear_solver-&gt;get_converged_reason();

  switch (reason)
  {
    case CONVERGED_RTOL_NORMAL:
    case CONVERGED_ATOL_NORMAL:
    case CONVERGED_RTOL:
    case CONVERGED_ATOL:
    case CONVERGED_ITS:
    case CONVERGED_CG_NEG_CURVE:
    case CONVERGED_CG_CONSTRAINED:
    case CONVERGED_STEP_LENGTH:
    case CONVERGED_HAPPY_BREAKDOWN:
      return true;
    case DIVERGED_NULL:
    case DIVERGED_ITS:
    case DIVERGED_DTOL:
    case DIVERGED_BREAKDOWN:
    case DIVERGED_BREAKDOWN_BICG:
    case DIVERGED_NONSYMMETRIC:
    case DIVERGED_INDEFINITE_PC:
    case DIVERGED_NAN:
    case DIVERGED_INDEFINITE_MAT:
    case CONVERGED_ITERATING:
    case DIVERGED_PCSETUP_FAILED:
      return false;
    default:
      mooseError(&quot;Unknown convergence flat in ActuallyExplicitEuler&quot;);
  }
}
</code></pre></div></div></body></html>