{
    "docs": [
        {
            "location": "/", 
            "text": "Numbat\n\n\nHigh-resolution simulations of density-driven convective mixing in porous media\n\n\nVersion 48408da, 17/03/2016\n\n\nNumbat is a massively-parallel code for high-resolution simulations of density-driven convective\nmixing in porous media built using the \nMOOSE framework\n.\n\n\nDensity-driven convective mixing in a porous medium", 
            "title": "Overview"
        }, 
        {
            "location": "/#numbat", 
            "text": "High-resolution simulations of density-driven convective mixing in porous media  Version 48408da, 17/03/2016  Numbat is a massively-parallel code for high-resolution simulations of density-driven convective\nmixing in porous media built using the  MOOSE framework .  Density-driven convective mixing in a porous medium", 
            "title": "Numbat"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Installation instructions\n\n\nTo install Numbat, follow these simple instructions.\n\n\nInstall MOOSE\n\n\nNumbat is based on the MOOSE framework, so the first step is to install\nMOOSE. For detailed installation instructions depending on your hardware, see\n\nwww.mooseframework.com\n.\n\n\nClone Numbat\n\n\nThe next step is to clone the Numbat repository to your local machine.\n\n\nIn the following, it is assumed that MOOSE was installed to the directory \n~/projects.\n If MOOSE was\ninstalled to a different directory, the following instructions must be modified accordingly.\n\n\nTo clone Numbat, use the following commands\n\n\ncd ~/projects\ngit clone https://github.com/cpgr/numbat.git\ncd numbat\ngit checkout master\n\n\n\nCompile Numbat\n\n\nNext, compile Numbat using\n\n\nmake -jn\n\n\n\nwhere \nn\n is the number of processing cores on the computer. If everything has gone well, Numbat should\ncompile without error, producing a binary named \nnumbat-opt\n.\n\n\nTest Numbat\n\n\nFinally, to test that the installation worked, the test suite can be run using\n\n\n./run_tests -jn\n\n\n\nwhere \nn\n is the number of processing cores on the computer.", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#installation-instructions", 
            "text": "To install Numbat, follow these simple instructions.  Install MOOSE  Numbat is based on the MOOSE framework, so the first step is to install\nMOOSE. For detailed installation instructions depending on your hardware, see www.mooseframework.com .  Clone Numbat  The next step is to clone the Numbat repository to your local machine.  In the following, it is assumed that MOOSE was installed to the directory  ~/projects.  If MOOSE was\ninstalled to a different directory, the following instructions must be modified accordingly.  To clone Numbat, use the following commands  cd ~/projects\ngit clone https://github.com/cpgr/numbat.git\ncd numbat\ngit checkout master  Compile Numbat  Next, compile Numbat using  make -jn  where  n  is the number of processing cores on the computer. If everything has gone well, Numbat should\ncompile without error, producing a binary named  numbat-opt .  Test Numbat  Finally, to test that the installation worked, the test suite can be run using  ./run_tests -jn  where  n  is the number of processing cores on the computer.", 
            "title": "Installation instructions"
        }, 
        {
            "location": "/governing-equations/", 
            "text": "Background theory\n\n\nGoverning equations\n\n\nNumbat implements the Boussinesq approximation to model density-driven convective mixing in porous media.\n\n\nThe governing equations for density-driven flow in porous media are Darcy's law\n\\begin{equation}\n\\mathbf{u} = - \\frac{\\mathbf{K}}{\\mu} \\left(\\nabla P + \\rho(c) g \\hat{\\mathbf{k}} \\right),\n\\label{eq:darcy}\n\\end{equation}\nwhere $\\mathbf{u} = (u, v, w)$ is the velocity vector, $\\mathbf{K}$ is permeability, $\\mu$ is the fluid viscosity, $P$ is the fluid pressure, $\\rho(c)$ is the fluid density as a function of solute concentration $c$, $g$ is gravity, and $\\hat{\\mathbf{k}}$ is the unit vector in the $z$ direction.\n\n\nThe fluid velocity must also satisfy the continuity equation\n\\begin{equation}\n\\nabla \\cdot \\mathbf{u} = 0,\n\\end{equation}\nand the solute concentration is governed by the convection - diffusion equation\n\n\n\\begin{equation}\n\\phi \\frac{\\partial c}{\\partial t} + \\mathbf{u} \\cdot \\nabla c = \\phi D \\nabla^2 c,\n\\label{eq:convdiff}\n\\end{equation}\nwhere $\\phi$ is the porosity, $t$ is time and $D$ is the diffusivity.\n\n\nDarcy's law and the convection-diffusion equations are coupled through the fluid density, which is given by\n\\begin{equation}\n\\rho(c) = \\rho_0 + \\frac{c}{c_0} \\Delta \\rho,\n\\label{eq:density}\n\\end{equation}\nwhere $c_0$ is the equilibrium concentration, and $\\Delta \\rho$ is the increase in density of the fluid at equilibrium concentration.\n\n\nThe boundary conditions are\n\\begin{align}\nw = 0,\n  \\quad z = 0, -H, \\\\\n\\frac{\\partial c}{\\partial z} = 0,\n \\quad z = -H, \\\\\nc = c_0,\n \\quad z = 0,\n\\end{align}\nwhich correspond to impermeable boundary conditions at the top and bottom boundaries, given by $z = 0$ and $z=-H$, respectively, and a saturated condition at the top boundary.\n\n\nInitially, there is no solute in the model\n\\begin{equation}\nc = 0, \\quad t = 0.\n\\end{equation}\n\n\nThe governing equations are solved using a streamfunction formulation in 2D and a vector potential formulation in 3D. As a result, we shall consider the two cases separately.\n\n\n2D solution\n\n\nIf we consider an anisotropic model, with vertical and horizontal permeabilities given by $k_z$ and $k_x$, respectively, we can non-dimensionalise the governing equations in 2D following \nEnnis-King \net. al\n (2005)\n. Defining the anisotropy ratio $\\gamma$ as\n\\begin{equation}\n\\gamma = \\frac{k_z}{k_x},\n\\label{eq:gamma}\n\\end{equation}\nwe scale the variables using\n\\begin{align}\nx = \\frac{\\phi \\mu D}{k_z \\Delta \\rho g \\gamma^{1/2}} \\hat{x}, \\quad z =  \\frac{\\phi \\mu D}{k_z \\Delta \\rho g} \\hat{z}, \\quad u = \\frac{k_z \\Delta \\rho g}{\\mu \\gamma^{1/2}} \\hat{u}, \\quad w = \\frac{k_z \\Delta \\rho g}{\\mu} \\hat{w} \\nonumber \\\\\nt = \\left(\\frac{\\phi \\mu}{k_z \\Delta \\rho g}\\right)^2 \\hat{t}, \\quad c = c_0 \\hat{c}, \\quad P = \\frac{\\mu \\phi D}{k_z}\\hat{P}, \\qquad \\qquad \\qquad\n\\label{eq:scales}\n\\end{align}\nwhere $\\hat{x}$ refers to a dimensionless variable. The governing equations in dimensionless form are then\n\\begin{align}\n\\mathbf{u} = \n - \\left(\\nabla P + c \\mathbf{\\hat{k}}\\right), \\label{eq:darcydim} \\\\\n\\mathbf{u} = \n \\,0, \\label{eq:ctydim} \\\\\n\\frac{\\partial c}{\\partial t} + \\mathbf{u} \\cdot \\nabla c = \n\\,  \\gamma \\frac{\\partial^2 c}{\\partial x^2} + \\frac{\\partial^2 c}{\\partial z^2}, \\label{eq:condiffdim}\n\\end{align}\nwhere we have dropped the hat on the dimensionless variables for brevity.\n\n\nThe dimensionless boundary conditions are\n\\begin{align}\nw = 0,\n  \\quad z = 0, -Ra, \\label{eq:dimbc1} \\\\\n\\frac{\\partial c}{\\partial z} = 0,\n \\quad z = -Ra, \\label{eq:dimbc2} \\\\\nc = 1,\n \\quad z = 0, \\label{eq:dimbc3}\n\\end{align}\nwhere $Ra$ is the Rayleigh number, defined as\n\\begin{equation}\nRa = \\frac{k_z \\Delta \\rho g H}{\\phi \\mu D}.\n\\label{eq:ra}\n\\end{equation}\n\n\nIn this form, the Rayleigh number only appears in the boundary conditions as the location of the lower boundary. Therefore, $Ra$ can be interpreted in this formalism as a dimensionless model height, and can be varied in simulations by simply changing the height of the mesh.\n\n\nFinally, the dimensionless initial condition is\n\\begin{equation}\nc = 0, \\quad t = 0.\n\\label{eq:ic}\n\\end{equation}\n\n\nFor isotropic models, where $k_x = k_z$ and hence $\\gamma = 1$, we recover the dimensionless equations given by \nSlim (2014)\n.\n\n\nThe coupled governing equations must be solved numerically. To simplify the numerical analysis, we introduce the streamfunction $\\psi(x,z,t)$ such that\n\\begin{equation}\nu = - \\frac{\\partial \\psi}{\\partial z}, \\quad w = \\frac{\\partial \\psi}{\\partial x}.\n\\label{eq:2Dstreamfunction}\n\\end{equation}\nThis definition satisfies the continuity equation, Eq. (\\ref{eq:ctydim}), immediately.\n\n\nThe pressure $P$ is removed from Eq. (\\ref{eq:darcydim}) by taking the curl of both sides and noting that $\\nabla \\times \\nabla P = 0$ for any $P$, to give\n\\begin{equation}\n\\nabla^2 \\psi = - \\frac{\\partial c}{\\partial x},\n\\label{eq:darcypsi}\n\\end{equation}\nwhere we have introduced the streamfunction $\\psi$ using Eq. (\\ref{eq:2Dstreamfunction}).\n\n\nThe convection-diffusion equation, Eq. (\\ref{eq:condiffdim}) becomes\n\\begin{equation}\\frac{\\partial c}{\\partial t} - \\frac{\\partial \\psi}{\\partial z} \\frac{\\partial c}{\\partial x} + \\frac{\\partial \\psi}{\\partial x} \\frac{\\partial c}{\\partial z} = \\gamma \\frac{\\partial^2 c}{\\partial x^2} + \\frac{\\partial^2 c}{\\partial z}.\n\\label{eq:condiffpsi}\n\\end{equation}\n\n\nThe boundary conditions become\n\\begin{align}\n\\frac{\\partial \\psi}{\\partial x} = 0,\n  \\quad z = 0, -Ra, \\\\\n\\frac{\\partial c}{\\partial z} = 0,\n \\quad z = -Ra, \\\\\nc = 1,\n \\quad z = 0,\n\\label{eq:bcpsi}\n\\end{align}\nwhile the initial condition is still given by Eq. (\\ref{eq:ic}).\n\n\nIn two dimensions, Numbat solves Eq's. (\\ref{eq:darcypsi}) and (\\ref{eq:condiffpsi}).\n\n\n3D solution\n\n\nWe now consider the case of a three-dimensional model. For simplicity, we consider the case where all lateral permeabilities are equal ($k_y = k_x$). The governing equations for the 3D model are identical to the 2D model. In dimensionless form, they are given by Eq's. (\\ref{eq:darcydim}) to (\\ref{eq:condiffdim}), with boundary conditions given by Eq's. (\\ref{eq:dimbc1}) to (\\ref{eq:dimbc3}), and initial condition given by Eq. (\\ref{eq:ic}).\n\n\nTo solve these governing equations in 3D, a different approach must be used as the streamfunction $\\psi$ is not defined in three dimensions. Instead, we define a vector potential $\\Psi = (\\psi_x, \\psi_y, \\psi_z)$ such that\n\\begin{equation}\n\\mathbf{u} = \\nabla \\times \\Psi.\n\\label{eq:Psi}\n\\end{equation}\n\n\nIt is important to note that the vector potential is only known up to the addition of the gradient of a scalar $\\zeta$ as\n\\begin{equation}\n\\nabla \\times \\left( \\Psi + \\nabla \\zeta \\right) = \\nabla \\times \\Psi \\quad \\forall \\zeta,\n\\end{equation}\nas $\\nabla \\times \\nabla \\zeta = 0$ for any scalar $\\zeta$. This uncertainty is referred to as guage freedom, and is common in electrodynamics. Taking the curl of Eq. (\\ref{eq:darcydim}) and substituting Eq. (\\ref{eq:Psi}), we have\n\\begin{equation}\n\\nabla(\\nabla \\cdot \\Psi) - \\nabla^2 \\Psi = \\left(- \\frac{\\partial c}{\\partial y}, \\frac{\\partial c}{\\partial x}, 0\\right),\n\\end{equation}\nwhere we have again used the fact that $\\nabla \\times \\nabla P = 0$. If we choose $\\nabla \\cdot \\Psi = 0$ to specify the guage condition, this simplifies to\n\\begin{equation}\n\\nabla^2 \\Psi = \\left(\\frac{\\partial c}{\\partial y},  -\\frac{\\partial c}{\\partial x}, 0\\right).\n\\label{eq:poisson}\n\\end{equation}\n\n\nAs shown in \nE and Liu (1997)\n, $\\nabla \\cdot \\Psi = 0$ is satisfied throughout the domain if\n\\begin{align}\n\\psi_x = \\psi_y = 0,\n \\quad z = 0, -Ra, \\nonumber \\\n\\frac{\\partial \\psi_z}{\\partial z} = 0, \n \\quad  z = 0, -Ra.\n\\end{align}\n\n\nThe governing equations are then\n\\begin{align}\n\\nabla^2 \\Psi = \\,\n \\left(\\frac{\\partial c}{\\partial y}, -\\frac{\\partial c}{\\partial x}, 0 \\right), \\label{eq:darcy3d} \\\\\n\\frac{\\partial c}{\\partial t} + \\mathbf{u} \\cdot \\nabla c = \\, \n \\gamma \\left( \\frac{\\partial^2 c}{\\partial x^2} + \\frac{\\partial^2 c}{\\partial y^2} \\right) + \\frac{\\partial^2 c}{\\partial z^2}, \\label{eq:convdiff3d}\n\\end{align}\nwhere the continuity is satisfied automatically because $\\nabla \\cdot \\left( \\nabla \\times \\Psi \\right) = 0$ for any $\\Psi$.\n\n\nFinally, it is straightforward to show that $\\psi_z = 0$ in order to satisfy $\\nabla^2 \\psi_z = 0$ and $\\frac{\\partial \\psi_z}{\\partial z} = 0$, which means that the vector potential has only $x$ and $y$ components,\n\\begin{equation}\n\\Psi = (\\psi_x, \\psi_y, 0),\n\\end{equation}\nand therefore the fluid velocity $\\mathbf{u} = (u, v, w)$ is\n\\begin{equation}\n\\mathbf{u} = \\left( -\\frac{\\partial \\psi_y}{\\partial z}, \\frac{\\partial \\psi_x}{\\partial z}, \\frac{\\partial \\psi_y}{\\partial x} - \\frac{\\partial \\psi_x}{\\partial y} \\right).\n\\end{equation}\n\n\nNote that if there is no $y$ dependence, Eq's. (\\ref{eq:darcy3d}) and (\\ref{eq:convdiff3d}) reduce to\n\\begin{align}\n\\nabla^2 \\Psi = \\, \n \\left(0, -\\frac{\\partial c}{\\partial x}, 0 \\right), \\\\\n\\frac{\\partial c}{\\partial t} + \\mathbf{u} \\cdot \\nabla c = \\, \n \\gamma \\frac{\\partial^2 c}{\\partial x^2}  + \\frac{\\partial^2 c}{\\partial z^2}.\n\\end{align}\nIt is simple to show that $\\nabla^2 \\psi_x = 0$ and $\\psi_x = 0$ at $z = 0, -Ra$ are only satisfied if $\\psi_x = 0$ in the entire domain. In this case, the governing equations reduce to the two-dimensional formulation, as expected.\n\n\nIn three dimensions, Numbat solves Eq's. (\\ref{eq:darcy3d}) and (\\ref{eq:convdiff3d}).", 
            "title": "Theory"
        }, 
        {
            "location": "/governing-equations/#background-theory", 
            "text": "Governing equations  Numbat implements the Boussinesq approximation to model density-driven convective mixing in porous media.  The governing equations for density-driven flow in porous media are Darcy's law\n\\begin{equation}\n\\mathbf{u} = - \\frac{\\mathbf{K}}{\\mu} \\left(\\nabla P + \\rho(c) g \\hat{\\mathbf{k}} \\right),\n\\label{eq:darcy}\n\\end{equation}\nwhere $\\mathbf{u} = (u, v, w)$ is the velocity vector, $\\mathbf{K}$ is permeability, $\\mu$ is the fluid viscosity, $P$ is the fluid pressure, $\\rho(c)$ is the fluid density as a function of solute concentration $c$, $g$ is gravity, and $\\hat{\\mathbf{k}}$ is the unit vector in the $z$ direction.  The fluid velocity must also satisfy the continuity equation\n\\begin{equation}\n\\nabla \\cdot \\mathbf{u} = 0,\n\\end{equation}\nand the solute concentration is governed by the convection - diffusion equation  \\begin{equation}\n\\phi \\frac{\\partial c}{\\partial t} + \\mathbf{u} \\cdot \\nabla c = \\phi D \\nabla^2 c,\n\\label{eq:convdiff}\n\\end{equation}\nwhere $\\phi$ is the porosity, $t$ is time and $D$ is the diffusivity.  Darcy's law and the convection-diffusion equations are coupled through the fluid density, which is given by\n\\begin{equation}\n\\rho(c) = \\rho_0 + \\frac{c}{c_0} \\Delta \\rho,\n\\label{eq:density}\n\\end{equation}\nwhere $c_0$ is the equilibrium concentration, and $\\Delta \\rho$ is the increase in density of the fluid at equilibrium concentration.  The boundary conditions are\n\\begin{align}\nw = 0,   \\quad z = 0, -H, \\\\\n\\frac{\\partial c}{\\partial z} = 0,  \\quad z = -H, \\\\\nc = c_0,  \\quad z = 0,\n\\end{align}\nwhich correspond to impermeable boundary conditions at the top and bottom boundaries, given by $z = 0$ and $z=-H$, respectively, and a saturated condition at the top boundary.  Initially, there is no solute in the model\n\\begin{equation}\nc = 0, \\quad t = 0.\n\\end{equation}  The governing equations are solved using a streamfunction formulation in 2D and a vector potential formulation in 3D. As a result, we shall consider the two cases separately.  2D solution  If we consider an anisotropic model, with vertical and horizontal permeabilities given by $k_z$ and $k_x$, respectively, we can non-dimensionalise the governing equations in 2D following  Ennis-King  et. al  (2005) . Defining the anisotropy ratio $\\gamma$ as\n\\begin{equation}\n\\gamma = \\frac{k_z}{k_x},\n\\label{eq:gamma}\n\\end{equation}\nwe scale the variables using\n\\begin{align}\nx = \\frac{\\phi \\mu D}{k_z \\Delta \\rho g \\gamma^{1/2}} \\hat{x}, \\quad z =  \\frac{\\phi \\mu D}{k_z \\Delta \\rho g} \\hat{z}, \\quad u = \\frac{k_z \\Delta \\rho g}{\\mu \\gamma^{1/2}} \\hat{u}, \\quad w = \\frac{k_z \\Delta \\rho g}{\\mu} \\hat{w} \\nonumber \\\\\nt = \\left(\\frac{\\phi \\mu}{k_z \\Delta \\rho g}\\right)^2 \\hat{t}, \\quad c = c_0 \\hat{c}, \\quad P = \\frac{\\mu \\phi D}{k_z}\\hat{P}, \\qquad \\qquad \\qquad\n\\label{eq:scales}\n\\end{align}\nwhere $\\hat{x}$ refers to a dimensionless variable. The governing equations in dimensionless form are then\n\\begin{align}\n\\mathbf{u} =   - \\left(\\nabla P + c \\mathbf{\\hat{k}}\\right), \\label{eq:darcydim} \\\\\n\\mathbf{u} =   \\,0, \\label{eq:ctydim} \\\\\n\\frac{\\partial c}{\\partial t} + \\mathbf{u} \\cdot \\nabla c =  \\,  \\gamma \\frac{\\partial^2 c}{\\partial x^2} + \\frac{\\partial^2 c}{\\partial z^2}, \\label{eq:condiffdim}\n\\end{align}\nwhere we have dropped the hat on the dimensionless variables for brevity.  The dimensionless boundary conditions are\n\\begin{align}\nw = 0,   \\quad z = 0, -Ra, \\label{eq:dimbc1} \\\\\n\\frac{\\partial c}{\\partial z} = 0,  \\quad z = -Ra, \\label{eq:dimbc2} \\\\\nc = 1,  \\quad z = 0, \\label{eq:dimbc3}\n\\end{align}\nwhere $Ra$ is the Rayleigh number, defined as\n\\begin{equation}\nRa = \\frac{k_z \\Delta \\rho g H}{\\phi \\mu D}.\n\\label{eq:ra}\n\\end{equation}  In this form, the Rayleigh number only appears in the boundary conditions as the location of the lower boundary. Therefore, $Ra$ can be interpreted in this formalism as a dimensionless model height, and can be varied in simulations by simply changing the height of the mesh.  Finally, the dimensionless initial condition is\n\\begin{equation}\nc = 0, \\quad t = 0.\n\\label{eq:ic}\n\\end{equation}  For isotropic models, where $k_x = k_z$ and hence $\\gamma = 1$, we recover the dimensionless equations given by  Slim (2014) .  The coupled governing equations must be solved numerically. To simplify the numerical analysis, we introduce the streamfunction $\\psi(x,z,t)$ such that\n\\begin{equation}\nu = - \\frac{\\partial \\psi}{\\partial z}, \\quad w = \\frac{\\partial \\psi}{\\partial x}.\n\\label{eq:2Dstreamfunction}\n\\end{equation}\nThis definition satisfies the continuity equation, Eq. (\\ref{eq:ctydim}), immediately.  The pressure $P$ is removed from Eq. (\\ref{eq:darcydim}) by taking the curl of both sides and noting that $\\nabla \\times \\nabla P = 0$ for any $P$, to give\n\\begin{equation}\n\\nabla^2 \\psi = - \\frac{\\partial c}{\\partial x},\n\\label{eq:darcypsi}\n\\end{equation}\nwhere we have introduced the streamfunction $\\psi$ using Eq. (\\ref{eq:2Dstreamfunction}).  The convection-diffusion equation, Eq. (\\ref{eq:condiffdim}) becomes\n\\begin{equation}\\frac{\\partial c}{\\partial t} - \\frac{\\partial \\psi}{\\partial z} \\frac{\\partial c}{\\partial x} + \\frac{\\partial \\psi}{\\partial x} \\frac{\\partial c}{\\partial z} = \\gamma \\frac{\\partial^2 c}{\\partial x^2} + \\frac{\\partial^2 c}{\\partial z}.\n\\label{eq:condiffpsi}\n\\end{equation}  The boundary conditions become\n\\begin{align}\n\\frac{\\partial \\psi}{\\partial x} = 0,   \\quad z = 0, -Ra, \\\\\n\\frac{\\partial c}{\\partial z} = 0,  \\quad z = -Ra, \\\\\nc = 1,  \\quad z = 0,\n\\label{eq:bcpsi}\n\\end{align}\nwhile the initial condition is still given by Eq. (\\ref{eq:ic}).  In two dimensions, Numbat solves Eq's. (\\ref{eq:darcypsi}) and (\\ref{eq:condiffpsi}).  3D solution  We now consider the case of a three-dimensional model. For simplicity, we consider the case where all lateral permeabilities are equal ($k_y = k_x$). The governing equations for the 3D model are identical to the 2D model. In dimensionless form, they are given by Eq's. (\\ref{eq:darcydim}) to (\\ref{eq:condiffdim}), with boundary conditions given by Eq's. (\\ref{eq:dimbc1}) to (\\ref{eq:dimbc3}), and initial condition given by Eq. (\\ref{eq:ic}).  To solve these governing equations in 3D, a different approach must be used as the streamfunction $\\psi$ is not defined in three dimensions. Instead, we define a vector potential $\\Psi = (\\psi_x, \\psi_y, \\psi_z)$ such that\n\\begin{equation}\n\\mathbf{u} = \\nabla \\times \\Psi.\n\\label{eq:Psi}\n\\end{equation}  It is important to note that the vector potential is only known up to the addition of the gradient of a scalar $\\zeta$ as\n\\begin{equation}\n\\nabla \\times \\left( \\Psi + \\nabla \\zeta \\right) = \\nabla \\times \\Psi \\quad \\forall \\zeta,\n\\end{equation}\nas $\\nabla \\times \\nabla \\zeta = 0$ for any scalar $\\zeta$. This uncertainty is referred to as guage freedom, and is common in electrodynamics. Taking the curl of Eq. (\\ref{eq:darcydim}) and substituting Eq. (\\ref{eq:Psi}), we have\n\\begin{equation}\n\\nabla(\\nabla \\cdot \\Psi) - \\nabla^2 \\Psi = \\left(- \\frac{\\partial c}{\\partial y}, \\frac{\\partial c}{\\partial x}, 0\\right),\n\\end{equation}\nwhere we have again used the fact that $\\nabla \\times \\nabla P = 0$. If we choose $\\nabla \\cdot \\Psi = 0$ to specify the guage condition, this simplifies to\n\\begin{equation}\n\\nabla^2 \\Psi = \\left(\\frac{\\partial c}{\\partial y},  -\\frac{\\partial c}{\\partial x}, 0\\right).\n\\label{eq:poisson}\n\\end{equation}  As shown in  E and Liu (1997) , $\\nabla \\cdot \\Psi = 0$ is satisfied throughout the domain if\n\\begin{align}\n\\psi_x = \\psi_y = 0,  \\quad z = 0, -Ra, \\nonumber \\\n\\frac{\\partial \\psi_z}{\\partial z} = 0,   \\quad  z = 0, -Ra.\n\\end{align}  The governing equations are then\n\\begin{align}\n\\nabla^2 \\Psi = \\,  \\left(\\frac{\\partial c}{\\partial y}, -\\frac{\\partial c}{\\partial x}, 0 \\right), \\label{eq:darcy3d} \\\\\n\\frac{\\partial c}{\\partial t} + \\mathbf{u} \\cdot \\nabla c = \\,   \\gamma \\left( \\frac{\\partial^2 c}{\\partial x^2} + \\frac{\\partial^2 c}{\\partial y^2} \\right) + \\frac{\\partial^2 c}{\\partial z^2}, \\label{eq:convdiff3d}\n\\end{align}\nwhere the continuity is satisfied automatically because $\\nabla \\cdot \\left( \\nabla \\times \\Psi \\right) = 0$ for any $\\Psi$.  Finally, it is straightforward to show that $\\psi_z = 0$ in order to satisfy $\\nabla^2 \\psi_z = 0$ and $\\frac{\\partial \\psi_z}{\\partial z} = 0$, which means that the vector potential has only $x$ and $y$ components,\n\\begin{equation}\n\\Psi = (\\psi_x, \\psi_y, 0),\n\\end{equation}\nand therefore the fluid velocity $\\mathbf{u} = (u, v, w)$ is\n\\begin{equation}\n\\mathbf{u} = \\left( -\\frac{\\partial \\psi_y}{\\partial z}, \\frac{\\partial \\psi_x}{\\partial z}, \\frac{\\partial \\psi_y}{\\partial x} - \\frac{\\partial \\psi_x}{\\partial y} \\right).\n\\end{equation}  Note that if there is no $y$ dependence, Eq's. (\\ref{eq:darcy3d}) and (\\ref{eq:convdiff3d}) reduce to\n\\begin{align}\n\\nabla^2 \\Psi = \\,   \\left(0, -\\frac{\\partial c}{\\partial x}, 0 \\right), \\\\\n\\frac{\\partial c}{\\partial t} + \\mathbf{u} \\cdot \\nabla c = \\,   \\gamma \\frac{\\partial^2 c}{\\partial x^2}  + \\frac{\\partial^2 c}{\\partial z^2}.\n\\end{align}\nIt is simple to show that $\\nabla^2 \\psi_x = 0$ and $\\psi_x = 0$ at $z = 0, -Ra$ are only satisfied if $\\psi_x = 0$ in the entire domain. In this case, the governing equations reduce to the two-dimensional formulation, as expected.  In three dimensions, Numbat solves Eq's. (\\ref{eq:darcy3d}) and (\\ref{eq:convdiff3d}).", 
            "title": "Background theory"
        }, 
        {
            "location": "/input-file-syntax/", 
            "text": "Input file syntax\n\n\nThe input file for a Numbat simulation is a simple, block-structured text file.\n\n\nA working example of a 2D problem can be found at \nhttps://github.com/cpgr/numbat/blob/master/examples/2D/2Dddc.i\n\n\nA working example of a 3D problem can be found at \nhttps://github.com/cpgr/numbat/blob/master/examples/3D/3Dddc.i\n\n\nEssential input\n\n\nDetails of the minimum input file requirements are given below.\n\n\nMesh\n\n\nAll simulations must feature a mesh. For the basic model with a rectangular mesh, the built-in MOOSE \nGeneratedMesh\n can be used to create a suitable mesh. In 2D, the input block looks like:\n\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  xmax = 1000\n  ymin = -200\n  ymax = 0\n  nx = 80\n  ny = 20\n  bias_y = 0.7\n[]\n\n\n\nThis creates a 2D mesh from $x = 0$ to $x = 1000$ and $y = -200$ to $y = 0$ with 80 elements in the $x$-direction and 20 elements in the $y$-direction. It is useful to have a mesh that is more refined at the top of the model, to accurately capture the initially small structure of the convective fingers. This is achieved using the built-in \nbias_y\n parameter.\n\n\nIn 3D, the Mesh block would look like:\n\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  xmax = 200\n  ymax = 200\n  zmin = -200\n  zmax = 0\n  nx = 10\n  ny = 10\n  nz = 10\n  bias_z = 0.7\n[]\n\n\n\nAgain, the mesh is refined at the top of the model using the the \nbias_z\n parameter.\n\n\nVariables\n\n\nFor a 2D model, the simulation must have two variables: \nconcentration\n and \nstreamfunction\n. This can be implemented in the input file using the following code:\n\n\n[Variables]\n[./concentration]\norder = FIRST\nfamily = LAGRANGE\n  [./InitialCondition]\n    type = PerturbationIC\n    variable = concentration\n    amplitude = 0.01\n    seed = 1\n  [../]\n[../]\n[./streamfunction]\n  order = FIRST\n  family = LAGRANGE\n  initial_condition = 0.0\n[../]\n[]\n\n\n\nInitial conditions can also be specified in the \nVariables\n block. In this case, the initial concentration is perturbed using a \nPerturbationIC\n to seed the instability.\n\n\nFor a 3D model, three variables are required: one \nconcentration\n variable and two \nstreamfunction\n variables corresponding to the \nx\n and \ny\n components. This can be implemented in the input file using:\n\n\n[Variables]  \n  [./concentration]  \n  [../]  \n  [./streamfunctionx]  \n  [../]  \n  [./streamfunctiony]  \n  [../]  \n[]\n\n\n\nKernels\n\n\nThree kernels are required for a 2D model: a \nDarcyDDC\n kernel for the \nstreamfunction\n variable, a \nConvectionDiffusionDDC\n kernel for the \nconcentration\n variable, and a \nTimeDerivative\n kernel also for the \nconcentration\n variable. An example for an isotropic model is\n\n\n[Kernels]\n  [./TwoDDarcyDDC]\n    type = DarcyDDC\n    variable = streamfunction\n    concentration_variable = concentration\n  [../]\n  [./TwoDConvectionDiffusionDDC]\n    type = ConvectionDiffusionDDC\n    variable = concentration\n    streamfunction_variable = streamfunction\n    coeff_tensor = '1 0 0 0 1 0 0 0 1'\n  [../]\n  [./TimeDerivative]\n    type = TimeDerivative\n    variable = concentration\n  [../]\n[]\n\n\n\nThe \ncoeff_tensor\n parameter in each convective diffusion kernel can be modified. The format of this\n\n\nFor 3D models, an additional \nDarcyDDC\n kernel is required for the additional stream function variable. An example of the kernels block for a 3D isotropic model is\n\n\n[Kernels]\n  [./ThreeDDarcyDDCx]\n    type = DarcyDDC\n    variable = streamfunctionx\n    concentration_variable = concentration\n    component = x\n  [../]\n  [./ThreeDDarcyDDCy]\n    type = DarcyDDC\n    variable = streamfunctiony\n    concentration_variable = concentration\n    component = y\n  [../]\n  [./ThreeDConvectionDiffusionDDC]\n    type = ConvectionDiffusionDDC\n    variable = concentration\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n    coeff_tensor = '1 0 0 0 1 0 0 0 1'\n  [../]\n  [./TimeDerivative]\n    type = TimeDerivative\n    variable = concentration\n  [../]\n[]\n\n\n\nIn the 3D case, it is important to note that the \nDarcyDDC\n kernel must specify the component that it applies to, and that the \nstreamfunction_variable\n keyword in the \nConvectionDiffusionDDC\n kernel must contain both \nstreamfunction\n variables ordered by the \nx\n component then the \ny\n component.\n\n\nBoundary conditions\n\n\nAppropriate boundary conditions must be prescribed. Typically, these will be constant concentration at the top of the model domain, periodic boundary conditions on the lateral sides (to mimic an infinite reservoir), and no-flow boundary conditions at the top and bottom surfaces.\n\n\nIn 2D, this can be achieved using the following input block:\n\n\n[BCs]\n  [./conctop]\n    type = DirichletBC\n    variable = concentration\n    boundary = top\n    value = 1.0\n  [../]\n  [./streamfuntop]\n    type = DirichletBC\n    variable = streamfunction\n    boundary = top\n    value = 0.0\n  [../]\n  [./streamfunbottom]\n    type = DirichletBC\n    variable = streamfunction\n    boundary = bottom\n    value = 0.0\n  [../]\n  [./periodic]\n    [./x]\n      variable = 'concentration streamfunction'\n      auto_direction = x\n    [../]\n  [../]\n[]\n\n\n\nIn this case, the \nconctop\n boundary condition is a Dirichlet condition at the top of the model that fixes the value of concentration to unity. It is useful to note that a MOOSE \nGeneratedMesh\n provides descriptive names for the sides of the model (top, bottom, left, right) which can be referenced in the input file. No-flow boundary conditions are prescribed on the top and bottom surfaces by holding the \nstreamfunction\n variable constant (in this case 0). Finally, periodic boundary conditions are applied by the \nperiodic\n block, which specifies that both the \nconcentration\n and \nstreamfunction\n variables are periodic on boundaries in the $x$-direction.\n\n\nA similar boundary condition block is used in 3D, except that no-flow boundaries must be imposed on both streamfunction variables, see below:\n\n\n[BCs]\n  [./conctop]\n    type = DirichletBC\n    variable = concentration\n    boundary = front\n    value = 1.0\n  [../]\n  [./streamfunxtop]\n    type = DirichletBC\n    variable = streamfunctionx\n    boundary = front\n    value = 0.0\n  [../]\n  [./streamfunxbottom]\n    type = DirichletBC\n    variable = streamfunctionx\n    boundary = back\n    value = 0.0\n  [../]\n  [./streamfunytop]\n    type = DirichletBC\n    variable = streamfunctiony\n    boundary = front\n    value = 0.0\n  [../]\n  [./streamfunybottom]\n    type = DirichletBC\n    variable = streamfunctiony\n    boundary = back\n    value = 0.0\n  [../]\n  [./Periodic]\n    [./xy]\n      variable = 'concentration streamfunctionx streamfunctiony'\n      auto_direction = 'x y'\n    [../]\n  [../]\n[]\n\n\n\nExecutioner\n\n\nEach MOOSE simulation must use an \nExecutioner\n, which provides parameters for the solve. In both 2D and 3D models, a transient \nExecutioner\n is used, an example of which is presented below:\n\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  dtmin = 0.1\n  dtmax = 200\n  end_time = 2000\n  solve_type = PJFNK\n  petsc_options_iname = '-ksp_type -pc_type -pc_sub_type'\n  petsc_options_value = 'gmres asm ilu'\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1\n    cutback_factor = 0.5\n    growth_factor = 2\n  [../]\n[]\n\n\n\nExecutioners\n are a standard MOOSE feature that are well documented on the \nMOOSE website\n, so no further detail is provided here.\n\n\nPreconditioning\n\n\nA default preconditioning block is used that provides all Jacobian entries to aid convergence. This is identical for both 2D and 3D models:\n\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n\nThis is a standard MOOSE feature that is documented on the \nMOOSE website\n, so no further detail is provided here.\n\n\nOutputs\n\n\nTo provide ouptut from the simulation, an \nOutputs\n block must be specified. An example is\n\n\n[Outputs]\n  [./console]\n    type = Console\n    perf_log = true\n    output_nonlinear = true\n  [../]\n  [./exodus]\n    type = Exodus\n    file_base = filename\n    execute_on = 'INITIAL TIMESTEP_END FINAL'\n  [../]\n[]\n\n\n\nIn this case, some output regarding the iterations is streamed to the console, while the results are provided in an Exodus file named \nfilename.e\n. There are a large number of output options available in MOOSE, see the \nMOOSE website\n for further details.\n\n\nOptional input\n\n\nWhile the above required blocks will enable a Numbat simulation to run, there are a number of optional input blocks that will improve the simulations are increase the amount of rsults provided.\n\n\nMesh adaptivity\n\n\nMOOSE features built-in mesh adaptivity that is extremely useful in Numbat simulations.  This can be included using:\n\n\n[Adaptivity]\n  marker = combomarker\n  max_h_level = 2\n  initial_marker = boxmarker\n  initial_steps = 1\n  [./Indicators]\n    [./gradjumpindicator]\n      type = GradientJumpIndicator\n      variable = concentration\n    [../]\n  [../]\n  [./Markers]\n    [./errormarker]\n      type = ErrorToleranceMarker\n      coarsen = 0.0025\n      refine = 0.005\n      indicator = gradjumpindicator\n    [../]\n    [./boxmarker]\n      type = BoxMarker\n      bottom_left = '0 -1.0 0'\n      top_right = '1000 0 0'\n      inside = refine\n      outside = dont_mark\n    [../]\n    [./combomarker]\n      type = ComboMarker\n      markers = 'boxmarker errormarker'\n    [../]\n  [../]\n[]\n\n\n\nFor details about mesh adaptivity, see the \nMOOSE website\n.\n\n\nFlux at the top boundary\n\n\nThe flux over the top boundary is of particular interest in many cases (especially convective mixing of $\\textrm{CO}_2$). This can be calculated at each time step using a \nPostprocessor\n:\n\n\n[Postprocessors]\n  [./boundaryfluxint]\n    type = SideFluxIntegral\n    variable = concentration\n    boundary = top\n    diffusivity = 1\n  [../]\n[]\n\n\n\nThe output of the \nPostprocessor\n can be saved to a \ncsv\n file by including the following additional sub-block in the \nOutputs\n block:\n\n\n[./csvoutput]\n  type = CSV\n  file_base = filename\n  execute_on = 'INITIAL TIMESTEP_END FINAL'\n[../]\n\n\n\nVelocity components\n\n\nThe velocity components in the $x$ and $y$ directions (in 2D), and $x$, $y$, and $z$ directions in 3D can be calculated using the auxiliary system. These velocity components are calculated using the streamfunction(s), see the governing equations for details.\n\n\nIn the 2D case, two auxiliary variables, $u$ and $w$, can be defined for the horizontal and vertical velocity components, respectively. Importantly, these auxiliary variables \nmust\n have constant monomial shape functions (these are referred to as \nelemental\n variables, as the value is constant over each mesh element). This restriction is due to the gradient of the streamfunction variable(s) being undefined for \nnodal\n auxiliary variables (for example, those using linear Lagrange shape functions). An example of the input syntax for the 2D case is\n\n\n[AuxVariables]\n  [./u]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./w]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n\n\nFor the 3D case, there is an additional horizontal velocity component (\nv\n), so the input syntax is\n\n\n[AuxVariables]\n  [./u]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./v]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./w]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n\n\nThe velocity components are calculated by \nVelocityDDCAux\n AuxKernels, one for each component. For the 2D case, the input syntax is\n\n\n[AuxKernels]\n  [./uAux]\n    type = VelocityDDCAux\n    variable = u\n    component = x\n    streamfunction_variable = streamfunction\n  [../]\n  [./wAux]\n    type = VelocityDDCAux\n    variable = w\n    component = y\n    streamfunction_variable = streamfunction\n  [../]\n[]\n\n\n\nFor the 3D case, three AuxKernels are required. Note that both streamfunction variables must be given, in the correct order ($x$ then $y$). An example of the input syntax is\n\n\n[AuxKernels]\n  [./uAux]\n    type = VelocityDDCAux\n    variable = u\n    component = x\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n  [./vAux]\n    type = VelocityDDCAux\n    variable = v\n    component = y\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n  [./wAux]\n    type = VelocityDDCAux\n    variable = w\n    component = z\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n[]", 
            "title": "Syntax"
        }, 
        {
            "location": "/input-file-syntax/#input-file-syntax", 
            "text": "The input file for a Numbat simulation is a simple, block-structured text file.  A working example of a 2D problem can be found at  https://github.com/cpgr/numbat/blob/master/examples/2D/2Dddc.i  A working example of a 3D problem can be found at  https://github.com/cpgr/numbat/blob/master/examples/3D/3Dddc.i", 
            "title": "Input file syntax"
        }, 
        {
            "location": "/input-file-syntax/#essential-input", 
            "text": "Details of the minimum input file requirements are given below.  Mesh  All simulations must feature a mesh. For the basic model with a rectangular mesh, the built-in MOOSE  GeneratedMesh  can be used to create a suitable mesh. In 2D, the input block looks like:  [Mesh]\n  type = GeneratedMesh\n  dim = 2\n  xmax = 1000\n  ymin = -200\n  ymax = 0\n  nx = 80\n  ny = 20\n  bias_y = 0.7\n[]  This creates a 2D mesh from $x = 0$ to $x = 1000$ and $y = -200$ to $y = 0$ with 80 elements in the $x$-direction and 20 elements in the $y$-direction. It is useful to have a mesh that is more refined at the top of the model, to accurately capture the initially small structure of the convective fingers. This is achieved using the built-in  bias_y  parameter.  In 3D, the Mesh block would look like:  [Mesh]\n  type = GeneratedMesh\n  dim = 3\n  xmax = 200\n  ymax = 200\n  zmin = -200\n  zmax = 0\n  nx = 10\n  ny = 10\n  nz = 10\n  bias_z = 0.7\n[]  Again, the mesh is refined at the top of the model using the the  bias_z  parameter.  Variables  For a 2D model, the simulation must have two variables:  concentration  and  streamfunction . This can be implemented in the input file using the following code:  [Variables]\n[./concentration]\norder = FIRST\nfamily = LAGRANGE\n  [./InitialCondition]\n    type = PerturbationIC\n    variable = concentration\n    amplitude = 0.01\n    seed = 1\n  [../]\n[../]\n[./streamfunction]\n  order = FIRST\n  family = LAGRANGE\n  initial_condition = 0.0\n[../]\n[]  Initial conditions can also be specified in the  Variables  block. In this case, the initial concentration is perturbed using a  PerturbationIC  to seed the instability.  For a 3D model, three variables are required: one  concentration  variable and two  streamfunction  variables corresponding to the  x  and  y  components. This can be implemented in the input file using:  [Variables]  \n  [./concentration]  \n  [../]  \n  [./streamfunctionx]  \n  [../]  \n  [./streamfunctiony]  \n  [../]  \n[]  Kernels  Three kernels are required for a 2D model: a  DarcyDDC  kernel for the  streamfunction  variable, a  ConvectionDiffusionDDC  kernel for the  concentration  variable, and a  TimeDerivative  kernel also for the  concentration  variable. An example for an isotropic model is  [Kernels]\n  [./TwoDDarcyDDC]\n    type = DarcyDDC\n    variable = streamfunction\n    concentration_variable = concentration\n  [../]\n  [./TwoDConvectionDiffusionDDC]\n    type = ConvectionDiffusionDDC\n    variable = concentration\n    streamfunction_variable = streamfunction\n    coeff_tensor = '1 0 0 0 1 0 0 0 1'\n  [../]\n  [./TimeDerivative]\n    type = TimeDerivative\n    variable = concentration\n  [../]\n[]  The  coeff_tensor  parameter in each convective diffusion kernel can be modified. The format of this  For 3D models, an additional  DarcyDDC  kernel is required for the additional stream function variable. An example of the kernels block for a 3D isotropic model is  [Kernels]\n  [./ThreeDDarcyDDCx]\n    type = DarcyDDC\n    variable = streamfunctionx\n    concentration_variable = concentration\n    component = x\n  [../]\n  [./ThreeDDarcyDDCy]\n    type = DarcyDDC\n    variable = streamfunctiony\n    concentration_variable = concentration\n    component = y\n  [../]\n  [./ThreeDConvectionDiffusionDDC]\n    type = ConvectionDiffusionDDC\n    variable = concentration\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n    coeff_tensor = '1 0 0 0 1 0 0 0 1'\n  [../]\n  [./TimeDerivative]\n    type = TimeDerivative\n    variable = concentration\n  [../]\n[]  In the 3D case, it is important to note that the  DarcyDDC  kernel must specify the component that it applies to, and that the  streamfunction_variable  keyword in the  ConvectionDiffusionDDC  kernel must contain both  streamfunction  variables ordered by the  x  component then the  y  component.  Boundary conditions  Appropriate boundary conditions must be prescribed. Typically, these will be constant concentration at the top of the model domain, periodic boundary conditions on the lateral sides (to mimic an infinite reservoir), and no-flow boundary conditions at the top and bottom surfaces.  In 2D, this can be achieved using the following input block:  [BCs]\n  [./conctop]\n    type = DirichletBC\n    variable = concentration\n    boundary = top\n    value = 1.0\n  [../]\n  [./streamfuntop]\n    type = DirichletBC\n    variable = streamfunction\n    boundary = top\n    value = 0.0\n  [../]\n  [./streamfunbottom]\n    type = DirichletBC\n    variable = streamfunction\n    boundary = bottom\n    value = 0.0\n  [../]\n  [./periodic]\n    [./x]\n      variable = 'concentration streamfunction'\n      auto_direction = x\n    [../]\n  [../]\n[]  In this case, the  conctop  boundary condition is a Dirichlet condition at the top of the model that fixes the value of concentration to unity. It is useful to note that a MOOSE  GeneratedMesh  provides descriptive names for the sides of the model (top, bottom, left, right) which can be referenced in the input file. No-flow boundary conditions are prescribed on the top and bottom surfaces by holding the  streamfunction  variable constant (in this case 0). Finally, periodic boundary conditions are applied by the  periodic  block, which specifies that both the  concentration  and  streamfunction  variables are periodic on boundaries in the $x$-direction.  A similar boundary condition block is used in 3D, except that no-flow boundaries must be imposed on both streamfunction variables, see below:  [BCs]\n  [./conctop]\n    type = DirichletBC\n    variable = concentration\n    boundary = front\n    value = 1.0\n  [../]\n  [./streamfunxtop]\n    type = DirichletBC\n    variable = streamfunctionx\n    boundary = front\n    value = 0.0\n  [../]\n  [./streamfunxbottom]\n    type = DirichletBC\n    variable = streamfunctionx\n    boundary = back\n    value = 0.0\n  [../]\n  [./streamfunytop]\n    type = DirichletBC\n    variable = streamfunctiony\n    boundary = front\n    value = 0.0\n  [../]\n  [./streamfunybottom]\n    type = DirichletBC\n    variable = streamfunctiony\n    boundary = back\n    value = 0.0\n  [../]\n  [./Periodic]\n    [./xy]\n      variable = 'concentration streamfunctionx streamfunctiony'\n      auto_direction = 'x y'\n    [../]\n  [../]\n[]  Executioner  Each MOOSE simulation must use an  Executioner , which provides parameters for the solve. In both 2D and 3D models, a transient  Executioner  is used, an example of which is presented below:  [Executioner]\n  type = Transient\n  scheme = bdf2\n  dtmin = 0.1\n  dtmax = 200\n  end_time = 2000\n  solve_type = PJFNK\n  petsc_options_iname = '-ksp_type -pc_type -pc_sub_type'\n  petsc_options_value = 'gmres asm ilu'\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1\n    cutback_factor = 0.5\n    growth_factor = 2\n  [../]\n[]  Executioners  are a standard MOOSE feature that are well documented on the  MOOSE website , so no further detail is provided here.  Preconditioning  A default preconditioning block is used that provides all Jacobian entries to aid convergence. This is identical for both 2D and 3D models:  [Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]  This is a standard MOOSE feature that is documented on the  MOOSE website , so no further detail is provided here.  Outputs  To provide ouptut from the simulation, an  Outputs  block must be specified. An example is  [Outputs]\n  [./console]\n    type = Console\n    perf_log = true\n    output_nonlinear = true\n  [../]\n  [./exodus]\n    type = Exodus\n    file_base = filename\n    execute_on = 'INITIAL TIMESTEP_END FINAL'\n  [../]\n[]  In this case, some output regarding the iterations is streamed to the console, while the results are provided in an Exodus file named  filename.e . There are a large number of output options available in MOOSE, see the  MOOSE website  for further details.", 
            "title": "Essential input"
        }, 
        {
            "location": "/input-file-syntax/#optional-input", 
            "text": "While the above required blocks will enable a Numbat simulation to run, there are a number of optional input blocks that will improve the simulations are increase the amount of rsults provided.  Mesh adaptivity  MOOSE features built-in mesh adaptivity that is extremely useful in Numbat simulations.  This can be included using:  [Adaptivity]\n  marker = combomarker\n  max_h_level = 2\n  initial_marker = boxmarker\n  initial_steps = 1\n  [./Indicators]\n    [./gradjumpindicator]\n      type = GradientJumpIndicator\n      variable = concentration\n    [../]\n  [../]\n  [./Markers]\n    [./errormarker]\n      type = ErrorToleranceMarker\n      coarsen = 0.0025\n      refine = 0.005\n      indicator = gradjumpindicator\n    [../]\n    [./boxmarker]\n      type = BoxMarker\n      bottom_left = '0 -1.0 0'\n      top_right = '1000 0 0'\n      inside = refine\n      outside = dont_mark\n    [../]\n    [./combomarker]\n      type = ComboMarker\n      markers = 'boxmarker errormarker'\n    [../]\n  [../]\n[]  For details about mesh adaptivity, see the  MOOSE website .  Flux at the top boundary  The flux over the top boundary is of particular interest in many cases (especially convective mixing of $\\textrm{CO}_2$). This can be calculated at each time step using a  Postprocessor :  [Postprocessors]\n  [./boundaryfluxint]\n    type = SideFluxIntegral\n    variable = concentration\n    boundary = top\n    diffusivity = 1\n  [../]\n[]  The output of the  Postprocessor  can be saved to a  csv  file by including the following additional sub-block in the  Outputs  block:  [./csvoutput]\n  type = CSV\n  file_base = filename\n  execute_on = 'INITIAL TIMESTEP_END FINAL'\n[../]  Velocity components  The velocity components in the $x$ and $y$ directions (in 2D), and $x$, $y$, and $z$ directions in 3D can be calculated using the auxiliary system. These velocity components are calculated using the streamfunction(s), see the governing equations for details.  In the 2D case, two auxiliary variables, $u$ and $w$, can be defined for the horizontal and vertical velocity components, respectively. Importantly, these auxiliary variables  must  have constant monomial shape functions (these are referred to as  elemental  variables, as the value is constant over each mesh element). This restriction is due to the gradient of the streamfunction variable(s) being undefined for  nodal  auxiliary variables (for example, those using linear Lagrange shape functions). An example of the input syntax for the 2D case is  [AuxVariables]\n  [./u]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./w]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]  For the 3D case, there is an additional horizontal velocity component ( v ), so the input syntax is  [AuxVariables]\n  [./u]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./v]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./w]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]  The velocity components are calculated by  VelocityDDCAux  AuxKernels, one for each component. For the 2D case, the input syntax is  [AuxKernels]\n  [./uAux]\n    type = VelocityDDCAux\n    variable = u\n    component = x\n    streamfunction_variable = streamfunction\n  [../]\n  [./wAux]\n    type = VelocityDDCAux\n    variable = w\n    component = y\n    streamfunction_variable = streamfunction\n  [../]\n[]  For the 3D case, three AuxKernels are required. Note that both streamfunction variables must be given, in the correct order ($x$ then $y$). An example of the input syntax is  [AuxKernels]\n  [./uAux]\n    type = VelocityDDCAux\n    variable = u\n    component = x\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n  [./vAux]\n    type = VelocityDDCAux\n    variable = v\n    component = y\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n  [./wAux]\n    type = VelocityDDCAux\n    variable = w\n    component = z\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n[]", 
            "title": "Optional input"
        }, 
        {
            "location": "/examples/example2D/", 
            "text": "2D example\n\n\nA working example of a 2D problem can be found at \nhttps://github.com/cpgr/numbat/blob/master/examples/2D/2Dddc.i\n.\n\n\nInput file\n\n\nThe complete input file for this problem is\n\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  xmax = 1000\n  ymin = -200\n  ymax = 0\n  nx = 80\n  ny = 20\n  bias_y = 0.7\n[]\n\n[Adaptivity]\n  marker = combomarker\n  max_h_level = 1\n  initial_marker = boxmarker\n  initial_steps = 1\n  [./Indicators]\n    [./gradjumpindicator]\n      type = GradientJumpIndicator\n      variable = concentration\n    [../]\n  [../]\n  [./Markers]\n    [./errormarker]\n      type = ErrorToleranceMarker\n      refine = 0.005\n      indicator = gradjumpindicator\n    [../]\n    [./boxmarker]\n      type = BoxMarker\n      bottom_left = '0 -1.0 0'\n      top_right = '1000 0 0'\n      inside = refine\n      outside = dont_mark\n    [../]\n    [./combomarker]\n      type = ComboMarker\n      markers = 'boxmarker errormarker'\n    [../]\n  [../]\n[]\n\n[Variables]\n  [./concentration]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = PerturbationIC\n      variable = concentration\n      amplitude = 0.02\n      seed = 1\n    [../]\n  [../]\n  [./streamfunction]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n[]\n\n[Kernels]\n  [./TwoDDarcyDDC]\n    type = DarcyDDC\n    variable = streamfunction\n    concentration_variable = concentration\n  [../]\n  [./TwoDConvectionDiffusionDDC]\n    type = ConvectionDiffusionDDC\n    variable = concentration\n    streamfunction_variable = streamfunction\n    coeff_tensor = '1 0 0 0 1 0 0 0 1'\n  [../]\n  [./TimeDerivative]\n    type = TimeDerivative\n    variable = concentration\n  [../]\n[]\n\n[AuxVariables]\n  [./u]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./w]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./uAux]\n    type = VelocityDDCAux\n    variable = u\n    component = x\n    streamfunction_variable = streamfunction\n  [../]\n  [./wAux]\n    type = VelocityDDCAux\n    variable = w\n    component = y\n    streamfunction_variable = streamfunction\n  [../]\n[]\n\n[BCs]\n  [./conctop]\n    type = DirichletBC\n    variable = concentration\n    boundary = top\n    value = 1.0\n  [../]\n  [./streamfuntop]\n    type = DirichletBC\n    variable = streamfunction\n    boundary = top\n    value = 0.0\n  [../]\n  [./streamfunbottom]\n    type = DirichletBC\n    variable = streamfunction\n    boundary = bottom\n    value = 0.0\n  [../]\n  [./Periodic]\n    [./x]\n      variable = 'concentration streamfunction'\n      auto_direction = x\n    [../]\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  dtmax = 100\n  end_time = 2500\n  start_time = 1\n  solve_type = PJFNK\n  nl_abs_tol = 1e-10\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1\n    cutback_factor = 0.5\n    growth_factor = 2\n  [../]\n  [./TimeIntegrator]\n    type = LStableDirk2\n  [../]\n[]\n\n[Postprocessors]\n  [./boundaryfluxint]\n    type = SideFluxIntegral\n    variable = concentration\n    boundary = top\n    diffusivity = 1\n  [../]\n  [./numdofs]\n    type = NumDOFs\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Outputs]\n  [./console]\n    type = Console\n    perf_log = true\n    output_nonlinear = true\n  [../]\n  [./exodus]\n    type = Exodus\n    file_base = 2Dddc\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n  [./csvoutput]\n    type = CSV\n    file_base = 2Dddc\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n[]\n\n\n\nRunning the example\n\n\nThis example can be run on the commandline using\n\n\nnumbat-opt -i 2Dddc.i\n\n\n\nAlternatively, this file can be run using the \nPeacock\n gui provided by MOOSE using\n\n\npeacock -i 2Dddc.i\n\n\n\nin the directory where \n2Dddc.i\n resides.", 
            "title": "2D example"
        }, 
        {
            "location": "/examples/example2D/#2d-example", 
            "text": "A working example of a 2D problem can be found at  https://github.com/cpgr/numbat/blob/master/examples/2D/2Dddc.i .  Input file  The complete input file for this problem is  [Mesh]\n  type = GeneratedMesh\n  dim = 2\n  xmax = 1000\n  ymin = -200\n  ymax = 0\n  nx = 80\n  ny = 20\n  bias_y = 0.7\n[]\n\n[Adaptivity]\n  marker = combomarker\n  max_h_level = 1\n  initial_marker = boxmarker\n  initial_steps = 1\n  [./Indicators]\n    [./gradjumpindicator]\n      type = GradientJumpIndicator\n      variable = concentration\n    [../]\n  [../]\n  [./Markers]\n    [./errormarker]\n      type = ErrorToleranceMarker\n      refine = 0.005\n      indicator = gradjumpindicator\n    [../]\n    [./boxmarker]\n      type = BoxMarker\n      bottom_left = '0 -1.0 0'\n      top_right = '1000 0 0'\n      inside = refine\n      outside = dont_mark\n    [../]\n    [./combomarker]\n      type = ComboMarker\n      markers = 'boxmarker errormarker'\n    [../]\n  [../]\n[]\n\n[Variables]\n  [./concentration]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = PerturbationIC\n      variable = concentration\n      amplitude = 0.02\n      seed = 1\n    [../]\n  [../]\n  [./streamfunction]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n[]\n\n[Kernels]\n  [./TwoDDarcyDDC]\n    type = DarcyDDC\n    variable = streamfunction\n    concentration_variable = concentration\n  [../]\n  [./TwoDConvectionDiffusionDDC]\n    type = ConvectionDiffusionDDC\n    variable = concentration\n    streamfunction_variable = streamfunction\n    coeff_tensor = '1 0 0 0 1 0 0 0 1'\n  [../]\n  [./TimeDerivative]\n    type = TimeDerivative\n    variable = concentration\n  [../]\n[]\n\n[AuxVariables]\n  [./u]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./w]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./uAux]\n    type = VelocityDDCAux\n    variable = u\n    component = x\n    streamfunction_variable = streamfunction\n  [../]\n  [./wAux]\n    type = VelocityDDCAux\n    variable = w\n    component = y\n    streamfunction_variable = streamfunction\n  [../]\n[]\n\n[BCs]\n  [./conctop]\n    type = DirichletBC\n    variable = concentration\n    boundary = top\n    value = 1.0\n  [../]\n  [./streamfuntop]\n    type = DirichletBC\n    variable = streamfunction\n    boundary = top\n    value = 0.0\n  [../]\n  [./streamfunbottom]\n    type = DirichletBC\n    variable = streamfunction\n    boundary = bottom\n    value = 0.0\n  [../]\n  [./Periodic]\n    [./x]\n      variable = 'concentration streamfunction'\n      auto_direction = x\n    [../]\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  dtmax = 100\n  end_time = 2500\n  start_time = 1\n  solve_type = PJFNK\n  nl_abs_tol = 1e-10\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1\n    cutback_factor = 0.5\n    growth_factor = 2\n  [../]\n  [./TimeIntegrator]\n    type = LStableDirk2\n  [../]\n[]\n\n[Postprocessors]\n  [./boundaryfluxint]\n    type = SideFluxIntegral\n    variable = concentration\n    boundary = top\n    diffusivity = 1\n  [../]\n  [./numdofs]\n    type = NumDOFs\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Outputs]\n  [./console]\n    type = Console\n    perf_log = true\n    output_nonlinear = true\n  [../]\n  [./exodus]\n    type = Exodus\n    file_base = 2Dddc\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n  [./csvoutput]\n    type = CSV\n    file_base = 2Dddc\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n[]  Running the example  This example can be run on the commandline using  numbat-opt -i 2Dddc.i  Alternatively, this file can be run using the  Peacock  gui provided by MOOSE using  peacock -i 2Dddc.i  in the directory where  2Dddc.i  resides.", 
            "title": "2D example"
        }, 
        {
            "location": "/examples/example3D/", 
            "text": "3D example\n\n\nA working example of a 3D problem can be found at \nhttps://github.com/cpgr/numbat/blob/master/examples/3D/3Dddc.i\n.\n\n\nInput file\n\n\nThe complete input file for this problem is\n\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  xmax = 200\n  ymax = 200\n  zmin = -200\n  zmax = 0\n  nx = 10\n  ny = 10\n  nz = 10\n[]\n\n[Adaptivity]\n  max_h_level = 2\n  initial_marker = boxmarker\n  initial_steps = 1\n  marker = combomarker\n  [./Indicators]\n    [./gradjumpindicator]\n      type = GradientJumpIndicator\n      variable = concentration\n    [../]\n  [../]\n  [./Markers]\n    [./errormarker]\n      type = ErrorToleranceMarker\n      coarsen = 2.5\n      refine = 1\n      indicator = gradjumpindicator\n    [../]\n    [./boxmarker]\n      type = BoxMarker\n      bottom_left = '0 0 -10'\n      top_right = '1000 1000 0'\n      inside = refine\n      outside = dont_mark\n    [../]\n    [./combomarker]\n      type = ComboMarker\n      markers = 'boxmarker errormarker'\n    [../]\n  [../]\n[]\n\n[Variables]\n  [./concentration]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./streamfunctionx]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n  [./streamfunctiony]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n[]\n\n[Kernels]\n  [./ThreeDDarcyDDCx]\n    type = DarcyDDC\n    variable = streamfunctionx\n    concentration_variable = concentration\n    component = x\n  [../]\n  [./ThreeDDarcyDDCy]\n    type = DarcyDDC\n    variable = streamfunctiony\n    concentration_variable = concentration\n    component = y\n  [../]\n  [./ThreeDConvectionDiffusionDDC]\n    type = ConvectionDiffusionDDC\n    variable = concentration\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n    coeff_tensor = '1 0 0 0 1 0 0 0 1'\n  [../]\n  [./TimeDerivative]\n    type = TimeDerivative\n    variable = concentration\n  [../]\n[]\n\n[AuxVariables]\n  [./u]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./v]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./w]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./uAux]\n    type = VelocityDDCAux\n    variable = u\n    component = x\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n  [./vAux]\n    type = VelocityDDCAux\n    variable = v\n    component = y\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n  [./wAux]\n    type = VelocityDDCAux\n    variable = w\n    component = z\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n[]\n\n[BCs]\n  [./conctop]\n    type = DirichletBC\n    variable = concentration\n    boundary = front\n    value = 1.0\n  [../]\n  [./streamfunxtop]\n    type = DirichletBC\n    variable = streamfunctionx\n    boundary = front\n    value = 0.0\n  [../]\n  [./streamfunxbottom]\n    type = DirichletBC\n    variable = streamfunctionx\n    boundary = back\n    value = 0.0\n  [../]\n  [./streamfunytop]\n    type = DirichletBC\n    variable = streamfunctiony\n    boundary = front\n    value = 0.0\n  [../]\n  [./streamfunybottom]\n    type = DirichletBC\n    variable = streamfunctiony\n    boundary = back\n    value = 0.0\n  [../]\n  [./Periodic]\n    [./xy]\n      variable = 'concentration streamfunctionx streamfunctiony'\n      auto_direction = 'x y'\n    [../]\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  dtmin = 0.1\n  dtmax = 1000\n  end_time = 3000\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm ilu 4'\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1\n  [../]\n[]\n\n[Postprocessors]\n  [./boundaryfluxint]\n    type = SideFluxIntegral\n    variable = concentration\n    boundary = front\n    diffusivity = 1\n  [../]\n  [./numdofs]\n    type = NumDOFs\n  [../]\n[]\n\n[Outputs]\n  output_initial = true\n  [./console]\n    type = Console\n    perf_log = true\n    output_nonlinear = true\n    output_linear = true\n  [../]\n  [./exodus]\n    type = Exodus\n    file_base = 3Dddc\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n  [./csvoutput]\n    type = CSV\n    file_base = 3Dddc\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n[]\n\n\n\nRunning the example\n\n\nThis example can be run on the commandline using\n\n\nnumbat-opt -i 3Dddc.i\n\n\n\nAlternatively, this file can be run using the \nPeacock\n gui provided by MOOSE using\n\n\npeacock -i 3Dddc.i\n\n\n\nin the directory where \n3Dddc.i\n resides.", 
            "title": "3D example"
        }, 
        {
            "location": "/examples/example3D/#3d-example", 
            "text": "A working example of a 3D problem can be found at  https://github.com/cpgr/numbat/blob/master/examples/3D/3Dddc.i .  Input file  The complete input file for this problem is  [Mesh]\n  type = GeneratedMesh\n  dim = 3\n  xmax = 200\n  ymax = 200\n  zmin = -200\n  zmax = 0\n  nx = 10\n  ny = 10\n  nz = 10\n[]\n\n[Adaptivity]\n  max_h_level = 2\n  initial_marker = boxmarker\n  initial_steps = 1\n  marker = combomarker\n  [./Indicators]\n    [./gradjumpindicator]\n      type = GradientJumpIndicator\n      variable = concentration\n    [../]\n  [../]\n  [./Markers]\n    [./errormarker]\n      type = ErrorToleranceMarker\n      coarsen = 2.5\n      refine = 1\n      indicator = gradjumpindicator\n    [../]\n    [./boxmarker]\n      type = BoxMarker\n      bottom_left = '0 0 -10'\n      top_right = '1000 1000 0'\n      inside = refine\n      outside = dont_mark\n    [../]\n    [./combomarker]\n      type = ComboMarker\n      markers = 'boxmarker errormarker'\n    [../]\n  [../]\n[]\n\n[Variables]\n  [./concentration]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./streamfunctionx]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n  [./streamfunctiony]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n[]\n\n[Kernels]\n  [./ThreeDDarcyDDCx]\n    type = DarcyDDC\n    variable = streamfunctionx\n    concentration_variable = concentration\n    component = x\n  [../]\n  [./ThreeDDarcyDDCy]\n    type = DarcyDDC\n    variable = streamfunctiony\n    concentration_variable = concentration\n    component = y\n  [../]\n  [./ThreeDConvectionDiffusionDDC]\n    type = ConvectionDiffusionDDC\n    variable = concentration\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n    coeff_tensor = '1 0 0 0 1 0 0 0 1'\n  [../]\n  [./TimeDerivative]\n    type = TimeDerivative\n    variable = concentration\n  [../]\n[]\n\n[AuxVariables]\n  [./u]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./v]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./w]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./uAux]\n    type = VelocityDDCAux\n    variable = u\n    component = x\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n  [./vAux]\n    type = VelocityDDCAux\n    variable = v\n    component = y\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n  [./wAux]\n    type = VelocityDDCAux\n    variable = w\n    component = z\n    streamfunction_variable = 'streamfunctionx streamfunctiony'\n  [../]\n[]\n\n[BCs]\n  [./conctop]\n    type = DirichletBC\n    variable = concentration\n    boundary = front\n    value = 1.0\n  [../]\n  [./streamfunxtop]\n    type = DirichletBC\n    variable = streamfunctionx\n    boundary = front\n    value = 0.0\n  [../]\n  [./streamfunxbottom]\n    type = DirichletBC\n    variable = streamfunctionx\n    boundary = back\n    value = 0.0\n  [../]\n  [./streamfunytop]\n    type = DirichletBC\n    variable = streamfunctiony\n    boundary = front\n    value = 0.0\n  [../]\n  [./streamfunybottom]\n    type = DirichletBC\n    variable = streamfunctiony\n    boundary = back\n    value = 0.0\n  [../]\n  [./Periodic]\n    [./xy]\n      variable = 'concentration streamfunctionx streamfunctiony'\n      auto_direction = 'x y'\n    [../]\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  dtmin = 0.1\n  dtmax = 1000\n  end_time = 3000\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm ilu 4'\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1\n  [../]\n[]\n\n[Postprocessors]\n  [./boundaryfluxint]\n    type = SideFluxIntegral\n    variable = concentration\n    boundary = front\n    diffusivity = 1\n  [../]\n  [./numdofs]\n    type = NumDOFs\n  [../]\n[]\n\n[Outputs]\n  output_initial = true\n  [./console]\n    type = Console\n    perf_log = true\n    output_nonlinear = true\n    output_linear = true\n  [../]\n  [./exodus]\n    type = Exodus\n    file_base = 3Dddc\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n  [./csvoutput]\n    type = CSV\n    file_base = 3Dddc\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n[]  Running the example  This example can be run on the commandline using  numbat-opt -i 3Dddc.i  Alternatively, this file can be run using the  Peacock  gui provided by MOOSE using  peacock -i 3Dddc.i  in the directory where  3Dddc.i  resides.", 
            "title": "3D example"
        }, 
        {
            "location": "/references/", 
            "text": "References\n\n\nE, W. and Liu, J. G., \nFinite difference methods for 3D viscous incompressible flows in the vorticity-vector potential formulation on nonstaggered grids\n, J. Comp. Phys., 138, 57--82 (1997) \n\n\nEnnis-King, J. and Paterson, L.,  \nRole of convective mixing in the long-term storage of carbon dioxide in deep saline aquifers\n, SPE J., 10, 349--356 (2005) \n\n\nSlim, A.C., \nSolutal-convection regimes in a two-dimensional porous medium\n, J. Fluid Mech., 741, 461--491 (2014)", 
            "title": "References"
        }, 
        {
            "location": "/references/#references", 
            "text": "E, W. and Liu, J. G.,  Finite difference methods for 3D viscous incompressible flows in the vorticity-vector potential formulation on nonstaggered grids , J. Comp. Phys., 138, 57--82 (1997)   Ennis-King, J. and Paterson, L.,   Role of convective mixing in the long-term storage of carbon dioxide in deep saline aquifers , SPE J., 10, 349--356 (2005)   Slim, A.C.,  Solutal-convection regimes in a two-dimensional porous medium , J. Fluid Mech., 741, 461--491 (2014)", 
            "title": "References"
        }, 
        {
            "location": "/download/", 
            "text": "Numbat user's guide\n\n\nThe documentation contained in this site is also available as a pdf file:\n\nNumbat user's guide", 
            "title": "Download PDF"
        }, 
        {
            "location": "/download/#numbat-users-guide", 
            "text": "The documentation contained in this site is also available as a pdf file: Numbat user's guide", 
            "title": "Numbat user's guide"
        }
    ]
}